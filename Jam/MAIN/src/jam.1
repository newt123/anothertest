.TH JAM 1 "15 January 1995"
.SH NAME
.B jam
\- 
.BR make (1)
redux

.SH SYNOPSIS
.B jam
[
.B \-a
] [
.B \-n
] [
.BI \-d " debug"
] [
.BI \-f " Jambase"
] ... [
.BI \-j " jobs"
] [
.BI \-t " target"
] ... [
.I target
] ...

.SH DESCRIPTION
.PP
.B Jam
recursively builds target files from their source files, using the file
.B Jambase
to define rules and the file
.B Jamfile
to list the targets and sources in terms of those rules.  
These two files define the dependency graph and the updating actions
for all targets:
.B jam
does not rely on suffix-driven implicit rules or directory contents.  A
.BR Jambase
is provided with
.BR jam ;
the user supplies the
.BR Jamfile .
.PP
See
.BR Jambase (5)
and
.BR Jamfile (5)
for information on writing Jamfiles.
This manual page describes the program that interprets
.B Jambase 
and
.BR Jamfile .

.SH OPTIONS
.PP
If
.I target
is provided on the command line,
.B jam
attempts to build that target; otherwise
.B jam
attempts to build the target "\fIall\fR".
.PP
.B Jam
supports the following options:
.IP "-a"
Build all targets, even if they are up-to-date.
.IP "-d\fI<n>\fR"
Set the debug level to \fI<n>\fR.  Interesting values are:
.PP
.RS
0 Emit only errors
.br
1 Emit update action tracing (default)
.br
2 Emit update commands
.br
3 Produce dependency information
.br
4 Show timestamps of bound files
.br
5 Show rule invocation
.br
6-9 debugging
.RE
.IP "-f\fI<file>\fR"
Read \fI<file>\fR instead of 
.BR Jambase .
.IP "-j\fI<jobs>\fR"
Run up to \fI<jobs>\fR shell commands concurrently (UNIX only).
.IP "-n"
Don't actually execute the updating actions, but do everything else.
.IP "-t\fI<target>\fR"
Pretend \fI<target>\fR is new, regardless of its actual timestamp.

.SH "THE JAM LANGUAGE"
.PP
The
.B jam
language supports defining and using rules, setting variables, and 
flow-of-control structures.
.B Jambase
and
.B Jamfile
share this common language.
.SS "Lexical Features"
.B Jam
treats its input files as whitespace-separated tokens, with two
exceptions: double quotes (") can enclose whitespace to embed it into a
token, and everything between the matching curly braces ({}) in the 
definition of a rule action is treated as a single string.
A backslash (\\) can escape a double quote.
.SS Targets
Targets and sources (collectively "targets") are files to be updated
and the files used in updating those targets.  A target is simply a
file name, either rooted or relative to the directory of
.BR jam 's
invocation.  The special syntax, \fIfile(member)\fR, refers to an
.BR ar (1)
library member.
The special syntax, \fI<grist>file\fR,
perturbs a file name to distinguish it from other files
with the same name.  The \fI<grist>\fR
is stripped from the name during binding (see \fBBinding\fR, below).
.SS Rules
.BR Jam 's
basic entity is called a rule, which is used to relate targets to their
sources.  A rule is defined in two parts: the
.B jam
statements to execute when the rule is invoked (essentially a procedure
call), and the actions (shell commands) to execute in order to update
the targets of the rule.  A rule may have a procedure definition, actions,
or both.
.PP
The 
.B jam
statements for defining and invoking rules are as follows, where
\fI<targets>\fR and \fI<sources>\fR are lists of file names, 
\fI<statements>\fR are 
.B jam
statements, and 
\fI<string>\fR
is a shell script:
.IP 
rule \fI<rulename>\fR { \fI<statements>\fR }
.IP
actions [ \fImodifiers\fR ] \fI<rulename>\fR { \fI<string>\fR }
.IP
\fI<rulename>\fR \fI<targets>\fR [ : \fI<sources>\fR ] ;
.PP
The first form defines a rule's procedure; the second defines the rule's
updating actions; the third invokes the rule.  Redefining a rule's
procedure or actions replaces the previous definition.
.PP
Invoking a rule executes the procedure for the rule (if any) and associates 
any update actions for the targets.  More than one update action may be
associated with a target: they are executed in the order in which they
are added.
.PP
In both the rule's procedure definition and the rule's actions, the
special variables $(<) and $(>) refer to the \fI<targets>\fR
and \fI<sources>\fR given at rule invocation.  
However, in the rule's actions, $(<) and $(>) refer to the
\fI<targets>\fR and \fI<sources>\fR
after they have been bound by the binding phase (see \fBBinding\fR, below).
.B Jam
issues a warning if $(<) or $(>) have elements not in the dependency graph.
.PP
The following action \fImodifiers\fR are understood:
.RS
.IP "\fBactions existing\fR"
$(>) includes only targets currently existing.
.IP "\fBactions ignore\fR"
The return status of the shell commands is ignored.
.IP "\fBactions piecemeal\fR"
The shell commands are repeatedly invoked with a subset of $(>)
small enough to fit in a command buffer.
.IP "\fBactions quietly\fR"
The action is not echoed to the standard output.
.IP "\fBactions together\fR"
The $(>) from multiple instances of the same action on the same
target are glommed together.
.IP "\fBactions updated\fR"
$(>) includes only targets marked for updating.
.RE
.SS "Built-in Rules"
.PP
.B Jam
has six built-in rules, none of which have updating actions:
.PP
.RS
.IP "DEPENDS \fI<targets>\fR : \fI<sources>\fR"
.br
Makes \fI<sources>\fR dependents of \fI<targets>\fR.
.IP "ECHO \fI<args>\fR"
.br
Blurts out the message \fI<args>\fR to stdout.
.IP "INCLUDES \fI<targets>\fR : \fI<sources>\fR"
.br
Makes \fI<sources>\fR dependents of anything of which \fI<targets>\fR 
are dependents.
.IP "NOCARE \fI<targets>\fR"
.br
Marks \fI<targets>\fR as possibly being bogus (see \fBBinding\fR, below).
.IP "NOTFILE \fI<targets>\fR"
.br
Marks \fI<targets>\fR as not being files (see \fBBinding,\fR below).
.IP "TEMPORARY \fI<targets>\fR"
.br
Marks \fI<targets>\fR as temporary (see \fBBinding,\fR below).
.RE
.SS "Flow of Control"
.PP
.B Jam
has several simple flow-of-control statements:
.IP
include \fI<a>\fR ;
.IP
for \fI<a>\fR in \fI<args>\fR { \fI<statements>\fR }
.IP
switch \fI<a>\fR { case \fI<v1>\fR : \fI<statements>\fR ; case \fI<v2>\fR : \fI<statements>\fR ; ... }
.IP
if \fI<cond>\fR { \fI<statements>\fR } else { \fI<statements>\fR }
.PP
The 
.B include 
statement includes the named file; the file is bound like regular
targets (see \fBBinding\fR, below), but unlike regular targets it cannot
be built.
.PP
The 
.B for 
loop executes \fI<statements>\fR for each value in \fI<args>\fR, setting the
variable \fI<a>\fR to the value; \fI<a>\fR is not variable-expanded.
.PP
The 
.B switch 
statement executes zero or one of the enclosed \fI<statements>\fR,
depending on which value \fI<a>\fR matches.  The \fI<v>\fR values are not 
variable-expanded.  The \fI<v>\fR values may include the following wildcards:
.PP
.RS
?		match any single character
.br
*		match zero or more characters
.br
[\fI<chars>\fR]	match any single character in \fI<chars>\fR
.RE
.PP
The 
.B if 
statement does the obvious; the 
.B else 
clause is optional.  
\fI<cond>\fR is built of:
.PP
.RS
\fI<a>\fR		true if \fI<a>\fR is a non-zero-length string
.br
\fI<a1>\fR = \fI<b1>\fR	strings equal
.br
\fI<a1>\fR != \fI<b1>\fR	strings not equal
.br
\fI<a1>\fR < \fI<b1>\fR	string less than
.br
\fI<a1>\fR <= \fI<b1>\fR	string less than or equal to
.br
\fI<a1>\fR > \fI<b1>\fR	string greater than
.br
\fI<a1>\fR >= \fI<b1>\fR	string greater than or equal to
.PP
! \fI<cond>\fR		condition not true
.br
\fI<cond>\fR && \fI<cond>\fR	conjunction
.br
\fI<cond>\fR || \fI<cond>\fR	disjunction
.br
( \fI<cond>\fR )		grouping
.RE
.PP
In comparisons, the arguments may (through variable expansion) be more
than one token, but only the first token takes part in the comparison.
If, through variable expansion, the argument is zero tokens, a single
token of a zero-length string is used instead.
.SS Variables
.PP
.B Jam
variables are lists of strings, with zero or more elements.  An undefined
variable is indistinguishable from a variable whose value is an empty
list.  Variables are either global or target-specific.  
All variables are referenced as $(VARIABLE).
.PP
A variable is defined with:
.IP
\fI<variable>\fR = \fI<values>\fR ;
.IP
\fI<variable>\fR += \fI<values>\fR ;
.IP
\fI<variable>\fR on \fI<targets>\fR = \fI<values>\fR ;
.IP
\fI<variable>\fR on \fI<targets>\fR += \fI<values>\fR ;
.IP
\fI<variable>\fR default = \fI<values>\fR ;
.IP
\fI<variable>\fR ?= \fI<values>\fR ;
.PP
The first two forms set \fI<variable>\fR globally;
the third and forth forms arrange for \fI<variable>\fR to take on a value
only during the binding and updating \fI<targets>\fR.
The \fB=\fR operator replaces any previous value of \fI<variable>\fR with 
\fI<values>\fR; the \fB+=\fR operation appends \fI<values>\fR to any 
previous value.
The final two forms set \fI<variable>\fR globally, but only if it was 
previously unset.  The two forms are synonymous.
.PP
On program start-up,
.B jam
imports the environment variable settings into
.B jam
variables;
.B jam
variables are not re-exported.
.SS "Variable Expansion"
.PP
Before executing a statement,
.B jam
performs variable expansion on each token that is not a keyword or rule
name. Such tokens with embedded variable references are replaced with
zero or more tokens.  Variable references are of the form $(\fIv\fR) or
$(\fIvm\fR), where \fIv\fR is the variable name, and \fIm\fR are optional 
modifiers.
.PP
Variable expansion in a rule's actions is similar to variable expansion
in statements, except that the action string is tokenized at whitespace
regardless of quoting.
.PP
The result of a token after variable expansion is the product of the
components of the token, where each component is a literal substring or
a list substituting a variable reference.  For example:
.PP
.RS
$(X)		-> a b c
.br
t$(X)		-> ta tb tc
.br
$(X)z		-> az bz cz
.br
$(X)-$(X)	-> a-a a-b a-c b-a b-b b-c c-a c-b c-c
.RE
.PP
The variable name and modifiers can themselves contain a variable
reference, and this partakes of the product as well: 
.PP
.RS
$(X)		-> a b c
.br
$(Y)		-> 1 2
.br
$(Z)		-> X Y
.br
$($(z))		-> a b c 1 2
.RE
.PP
Because of this product expansion, if any variable reference in a token
is undefined, the result of the expansion is an empty list.
.PP
Modifiers to a variable are of two varieties: sub-element selection and
file name editing.  They are:
.PP
.IP "[\fI<n>\fR]"
Select only element number \fI<n>\fR (starting at 1).  If the variable contains
fewer than \fI<n>\fR elements, the result is a zero-element list.
.IP "[\fI<n>\fR-\fI<m>\fR]"
Select only elements number \fI<n>\fR through \fI<m>\fR.
.IP "[\fI<n>\fR-]"
Select only elements number \fI<n>\fR through the last.
.IP ":G=\fI<grist>\fR"
Replace the grist of the file name with \fI<grist>\fR.
.IP ":D=\fI<path>\fR"
Replace directory component of file name with \fI<path>\fR.
.IP ":B=\fI<base>\fR"
Replace the base part of file name with \fI<base>\fR.
.IP ":S=\fI<suf>\fR"
Replace the suffix of file name with \fI<suf>\fR.
.IP ":M=\fI<mem>\fR"
Replace the archive member name with \fI<mem>\fR.
.IP ":R=\fI<root>\fR"
Prepend \fI<root>\fR to the whole file name, if not already rooted.
.IP ":\fI<components>\fR"
Remove components not listed; components
is one or more of
.BR GDBSM .

.SH OPERATION
.B Jam
has three phases of operation: parsing, binding, and updating.  
.SS Parsing
.PP
.B Jam
parses the 
.B Jambase 
file, which by default includes
.BR Jamfile .
The results of parsing are: the dependency graph of targets; update
actions associated with the targets; and variables set to specific
values.
.PP
.SS Binding
After parsing,
.B jam
recursively descends the dependency graph, attempting to locate each
target file and determine if it is in need of updating.  
.PP
By default, a target is located at the actual path of the target,
relative to the directory of
.BR jam 's
invocation.  If
.RB $( LOCATE )
is set to a directory name,
.B jam
locates the target in that directory; else if
.RB $( SEARCH )
is set to a directory list,
.B jam
first searches along the directory list for the target file.  If the
target name has a rooted directory component then
.RB $( SEARCH )
and
.RB $( LOCATE )
do not apply: the target is located at the actual path of the
target.  If a target is marked as not being a file (using the built-in
rule NOTFILE), it is left unbound to a file name.
.PP
A target is marked for updating if it cannot be found, if its
filesystem modification time is older than any of its sources, or if
any of its sources is marked for updating.  If a target is missing,
no updating actions are associated with the target, and the target has
not been marked with the built-in rule NOCARE, then
.B jam
emits a warning.  If a target is missing and is marked as temporary
(with the built-in rule TEMPORARY), then its parent's modification time
is used when comparing against sources.  If a target is marked as
not being a file (using the built-in rule, NOTFILE), it is marked for
updating only if any of its sources is marked for updating.
.PP
If a target is a source file that includes header files,
.B jam
invokes the 
.RB $( HDRRULE )
rule on the target, giving the (unbound) names of
the header files as sources.  A target is scanned for header file
dependencies if
.RB $( HDRSCAN )
is set to a
.BR regexp (3)
pattern with ()'s surrounding the include file name (see
.B HDRPATTERN
in
.BR Jambase (5)
for an example).
.PP
Between binding and updating,
.B jam
announces the number of targets to be updated.
.SS Updating
After binding,
.B jam
again recursively descends the dependency graph, this time executing the
update actions for each target marked for update during the
binding phase.  If a target's updating actions fail, then all targets
which depend on it are skipped.

.SH DIAGNOSTICS
.PP
In addition to generic error messages, 
.B jam
may emit one of the following:
.PP
warning: unknown rule X
.IP
A rule was invoked that has not been defined with
an "actions" or "rule" statement.
.PP
using N temp target(s)
.IP
Targets marked as being temporary (but nonetheless present)
have been found.
.PP
updating N target(s)
.IP
Targets are out-of-date and will be updated.
.PP
can't make N target(s)
.IP
Due to sources not being found, targets cannot be made.
.PP
warning: X depends on itself
.IP
A target depends on itself either directly or through its sources.
This most frequently happens with header file inclusions.
.PP
don't know how to make X
.IP
A needed target is not present and no actions are defined to create
the target.
.PP
X skipped for lack of Y
.IP
A source failed to build, and thus a target cannot be built.
.PP
warning: using independent target X
.IP
A target that does is not a dependent of any target being made is
being referenced with $(<) or $(>).  
.PP
X removed
.IP
.B Jam
removed a partially built target after being interrupted.

.SH FILES
/usr/local/bin/jam
/usr/local/lib/jam/Jambase

.SH BUGS, LIMITATIONS
.PP
Because the
.B include
statement works by pushing a new file in the input stream of the
scanner rather than recursively invoking the parser on the new file,
multiple include statements in a rule's procedure causes the files
to be included in reverse order.
.PP
If the
.B include
statement appears inside an 
.B if
block, the parser's attempt to find the
.B else
will cause the text of the included file to appear after the first
token following the statement block. 
This is rarely what is intended.
.PP
In a rule's actions, only $(<) and $(>) refer to the bound file names:
all other variable references get the unbound names.
.PP
Searching for include files is slow.
.PP
With the 
.B \-j 
flag, errors from failed commands can get staggeringly mixed up.

.SH SEE ALSO
.BR Jambase (5),
.BR Jamfile (5)
