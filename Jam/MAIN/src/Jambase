#
# /+\
# +\	Copyright 1993, 1995 Christopher Seiwald.
# \+/
#
# This file is part of Jam - see jam.c for Copyright information.
#

#
# JAMBASE - jam ruleset providing make(1)-like functionality
#
# Supports UNIX and NT.
#
# 12/27/93 (seiwald) - purturb library sources with SOURCE_GRIST
# 04/18/94 (seiwald) - use 'default =' when setting OS specific vars
# 04/21/94 (seiwald) - do RmTemps together
# 05/05/94 (seiwald) - all supported C compilers support -o: relegate
#		       RELOCATE as an option; set Ranlib to "" to disable it
# 06/01/94 (seiwald) - new 'actions existing' to do existing sources
# 08/25/94 (seiwald) - new ObjectCcFlags rule to append to per-target CCFLAGS
# 08/29/94 (seiwald) - new ObjectHdrs rule to append to per-target HDRS
# 09/19/94 (seiwald) - LinkLibraries and Undefs now append
#		     - Rule names downshifted.
# 10/06/94 (seiwald) - Dumb yyacc stuff moved into Jamfile.
# 10/14/94 (seiwald) - (Crude) support for .s, .C, .cc, .cpp, and .f files.
# 01/08/94 (seiwald) - Shell now handled with awk, not sed
# 01/09/94 (seiwald) - Install* now take dest directory as target
# 01/10/94 (seiwald) - All entries sorted.
# 01/10/94 (seiwald) - NT support moved in, with LauraW's help.

# Rules defined by this file:
#
# as obj.o : source.s ;			.s -> .o
# Bulk dir : files ;			populate directory with many files
# Cc obj.o : source.c ;			.c -> .o
# C++ obj.o : source.cc ;		.cc -> .o
# Clean clean : sources ;		remove sources with 'jam clean'
# File dest : source ;			copy file
# Fortran obj.o : source.f ;		.f -> .o
# Hardlink target : source ;		make link from source to target
# HdrRule source : headers ;		handle #includes
# Install target : source ;		install any single file
# InstallBin dir : sources ;		install binaries
# InstallLib dir : sources ;		install files
# InstallMan dir : sources ;		install man pages
# InstallShell dir : sources ;		install shell scripts
# Lex source.c : source.l ;		.l -> .c
# Library lib : source ;		archive library from compiled sources
# LibraryFromObjects lib : objects ;	archive library from objects
# LinkLibraries image : libraries ;	bag libraries onto a Main
# Main image : source ;			link executable from compiled sources
# MainFromObjects image : objects ;	link executable from objects
# Object object : source ;		compile object from source
# ObjectCcFlags source : flags ;	add compiler flags for object
# ObjectHdrs source : dirs ;		add include directories for object
# Objects sources ;			compile sources
# RmTemps target : sources ;		remove temp sources after target made
# Setuid image ;			mark an executable Setuid
# SubDir TOP d1 d2 ... ;		start a subdirectory Jamfile
# SubDirObjectCcFlags flags ;		add compiler flags until next SubDir
# SubDirObjectHdrs dirs ;		add include dirs until next SubDir
# SubInclude TOP d1 d2 ... ;		include a subdirectory Jamfile
# Shell exe : source ;			make a shell executable
# Undefines image : symbols ;		save undef's for linking
# UserObject object : source ;		handle unknown suffixes for Object
# Yacc source.c : source.y ;		.y -> .c
#

# Brief review of the jam language:
#
# Statements:
#	rule RULE - statements to process a rule
#	actions RULE - system commands to carry out target update
#
# Modifiers on actions:
#	together - multiple instances of same rule on target get executed
#		   once with their sources ($(>)) concatenated
#	updated - refers to updated sources ($(>)) only
#	ignore - ignore return status of command
#	quietly - don't trace its execution unless verbose
#	piecemeal - iterate command each time with a small subset of $(>)
#	existing - refers to currently existing sources ($(>)) only
#
# Special rules:
#	DEPENDS - builds the dependency graph
#	ECHO - blurt out targets on stdout
#	INCLUDES - marks sources as headers for target (a codependency)
#	NOCARE - don't panic if the target can't be built
#	NOTFILE - ignore the timestamp of the target (it's not a file)
#	TEMPORARY - target need not be present if sources haven't changed
#
# Special variables set by jam:
#	$(<) - targets of a rule (to the left of the :)
#	$(>) - sources of a rule (to the right of the :)
#	$(UNIX) - true on UNIX
#	$(VMS) - true on VMS
#	$(OS) - name of OS - varies wildly
#
# Special variables used by jam:
#	SEARCH - where to find something (used during binding and actions)
#	LOCATE - where to plop something not found with SEARCH
#	HDRRULE - rule to call to handle include files
#	HDRSCAN - egrep regex to extract include files
#
# Special targets:
#	all - default if none given on command line

# Initialize variables
#
# "default =" - set only if unset

#
# OS specific variable settings
#

switch $(OS)
{
case AIX :	LINKLIBS default = -lbsd ;
case DGUX :	RANLIB default = "" ;
case IRIX :	RANLIB default = "" ;
case HPUX :	RANLIB default = "" ;
case PTX :	RANLIB default = "" ;
case SOLARIS :	RANLIB default = "" ;
}

if $(UNIX)
{
	AR		default = ar ru ;
	AS		default = as ;
	ASFLAGS		default = ;
	BINDIR		default = /usr/local/bin ;
	C++		default = gcc ;
	C++FLAGS	default = ;
	CC		default = cc ;
	CCFLAGS		default = ;
	CP		default = cp ;
	CHMOD		default = chmod ;
	EXEMODE		default = 711 ;
	FILEMODE	default = 644 ;
	FORTRAN		default = f77 ;
	FORTRANFLAGS	default = ;
	HDRS		default = ;
	INSTALL		default = install ;
	LEX		default = lex ;
	LIBDIR		default = /usr/local/lib ;
	LINK		default = $(CC) ;
	LINKFLAGS	default = $(CCFLAGS) ;
	LINKLIBS	default = ;
	LN		default = ln ;
	MANDIR		default = /usr/local/man ;
	MKDIR		default = mkdir ;
	MV		default = mv -f ;
	OPTIM		default = -O ;
	RANLIB		default = ranlib ;
	RM		default = rm -f ;
	SHELLHEADER	default = "#!/bin/sh" ;
	SHELLMODE	default = 755 ;
	SLASH		default = / ;
	STDHDRS		default = /usr/include ;
	SUBLIB		default = .a ;
	SUFOBJ		default = .o ;
	SUFEXE		default = "" ;
	UNDEFFLAG	default = "-u _" ;
	YACC		default = yacc -d ;
}
else if $(NT)
{
    if $(BCCROOT)
    {
	ECHO "Compiler is Borland C++" ;

	AR		default = tlib ;
	ARFLAGS		default = /C /P64 ;
	CC		default = bcc32 ;
	CCFLAGS		default = -v -w-  ;
	MV		default = rename ;
	RM		default = del ;
	RW		default = $(BCCROOT)\\lib\\rw ;
	RWLIBPATH	default = $(RW)\\lib ;
	LINK		default = $(CC) ;
	LINKFLAGS	default = $(CCFLAGS) ;
	SLASH		default = \\ ;
	STDLIBPATH	default = $(BCCROOT)\\lib ;
	STDHDRS		default = $(BCCROOT)\\include ;
	SUBLIB		default = .lib ;
	SUFOBJ		default = .obj ;
	SUFEXE		default = .exe ;
    }
    else if $(MSVCNT)
    {
	ECHO "Compiler is Microsoft Visual C++" ;

	AR		default = lib ;
	CC		default = cl ;
	CCFLAGS		default = /D \"NT\" ;
	MV		default = rename ;
	RM		default = del ;
	RW		default = $(MSVCNT)\\lib\\rw ;
	RWLIBPATH	default = $(RW)\\lib ;
	LINK		default = $(CC) ;
	LINKFLAGS	default = $(CCFLAGS) ;
	LINKLIBS	default = $(MSVCNT)\\lib\\advapi32.lib
				$(MSVCNT)\\lib\\libcmt.lib
				$(MSVCNT)\\lib\\libc.lib
				$(MSVCNT)\\lib\\oldnames.lib
				$(MSVCNT)\\lib\\kernel32.lib ;
	OPTIM		default =  ;
	SLASH		default = \\ ;
	STDHDRS		default = $(MSVCNT)\\include ;
	SUBLIB		default = .lib ;
	SUFOBJ		default = .obj ;
	SUFEXE		default = .exe ;
	UNDEFFLAG	default = "/u _" ;
    }
}
else if $(VMS)
{
	AS		default = as ;
	CC		default = cc ;
	CCFLAGS		default = ;
	CRELIB		default = true ;
	EXEMODE		default = (w:e) ;
	FILEMODE	default = (w:r) ;
	HDRS		default = ;
	LEX		default = lex ;
	LINK		default = link ;
	LINKFLAGS	default = ;
	LINKLIBS	default = ;
	MV		default = rename ;
	OPTIM		default = ;
	RM		default = delete ;
	SHELLMODE	default = (w:er) ;
	SLASH		default = . ;
	STDHDRS		default = "" decc$library_include ;
	SUBLIB		default = .olb ;
	SUFOBJ		default = .obj ;
	SUFEXE		default = .exe ;

	switch $(OS) 
	{
	case OPENVMS : CCFLAGS default = /stand=vaxc ;
	case VMS     : LINKLIBS default = sys$library:vaxcrtl.olb/lib ;
	}
}

JAMFILE		default = Jamfile ;
JAMRULES	default = ;

HDRPATTERN = "^#[	 ]*include[	 ]*[<\"](.*)[\">].*$" ;

#
# Base dependencies - first for "bootstrap" kinds of rules
#

DEPENDS all : first shell files lib exe ;
NOTFILE all first shell files lib exe ;

#
# Rules
#

rule As
{
	DEPENDS $(<) : $(>) ;
}

rule Bulk
{
	for i in $(>)
	{
	    File $(i:D=$(<)) : $(i) ;
	}
}

rule Cc
{
	DEPENDS $(<) : $(>) ;

	# Just to clarify here: this sets the per-target CCFLAGS to
	# be the current value of (global) CCFLAGS and SUBDIRCCFLAGS.

	CCFLAGS on $(<) += $(CCFLAGS) $(SUBDIRCCFLAGS) ;

	# If the compiler's -o flag doesn't work, relocate the .o

	if $(RELOCATE)
	{
	    CcMv $(<) : $(>) ;
	}

	if $(VMS) && $(HDRS[1])
	{
	    SLASHINC on $(<) = "/inc=(" $(HDRS[1]) ,$(HDRS[2-]) ")" ;
	}
}

rule C++
{
	DEPENDS $(<) : $(>) ;
}

rule File
{
	DEPENDS files : $(<) ;
	DEPENDS $(<) : $(>) ;
	SEARCH on $(>) = $(SEARCH_SOURCE) ;
}

rule Fortran
{
	DEPENDS $(<) : $(>) ;
}

rule HardLink
{
	DEPENDS files : $(<) ;
	DEPENDS $(<) : $(>) ;
	SEARCH on $(>) = $(SEARCH_SOURCE) ;
}

rule HdrRule
{
	# HdrRule source : headers ;

	# N.B.	This rule is called during binding, potentially after
	# the fate of many targets has been determined, and must be
	# used with caution: don't add dependencies to unrelated
	# targets, and don't set variables on $(<).

	# Tell Jam that anything depending on $(<) also depends on $(>),
	# set SEARCH so Jam can find the headers, but then say we don't
	# care if we can't actually find the headers (they may have been
	# within ifdefs),

	INCLUDES $(<) : $(>) ;
	SEARCH on $(>) = $(HDRSEARCH) ;
	NOCARE $(>) ;

	# Propagate on $(<) to $(>)

	HDRSEARCH on $(>) = $(HDRSEARCH) ;
	HDRSCAN on $(>) = $(HDRSCAN) ;
	HDRRULE on $(>) = $(HDRRULE) ;
}

rule Install
{
	DEPENDS install : $(<) ;
	DEPENDS $(<) : $(>) ;
	SEARCH on $(>) = $(SEARCH_SOURCE) ;
}

rule InstallBin
{
	for i in $(>)
	{
	    Install $(i:R=$(<)) : $(i) ;
	    INSTALLMODE on $(i:R=$(<)) = $(EXEMODE) ;
	}
}

rule InstallLib
{
	for i in $(>)
	{
	    Install $(i:R=$(<)) : $(i) ;
	    INSTALLMODE on $(i:R=$(<)) = $(FILEMODE) ;
	}
}

rule InstallMan
{
	# Really this just strips the . from the suffix

	for i in $(>)
	{
	    switch $(i:S)
	    {
	    case .1 : S = 1 ; case .2 : S = 2 ; case .3 : S = 3 ;
	    case .4 : S = 4 ; case .5 : S = 5 ; case .6 : S = 6 ;
	    case .7 : S = 7 ; case .8 : S = 8 ; case .l : S = l ;
	    case .n : S = n ; case .man : S = 1 ;
	    }

	    D = $(i:D=man$(S):S=.$(S)) ;

	    Install $(D:R=$(<)) : $(i) ;
	    INSTALLMODE on $(D:R=$(<)) = $(FILEMODE) ;
	}
}

rule InstallShell
{
	for i in $(>)
	{
	    Install $(i:R=$(<)) : $(i) ;
	    INSTALLMODE on $(i:R=$(<)) = $(SHELLMODE) ;
	}
}

rule Lex
{
	DEPENDS $(<) : $(>) ;
	LOCATE on $(<) = $(LOCATE_TARGET) ;
	Clean clean : $(<) ;
}

rule Library
{
	LibraryFromObjects $(<) : $(>:S=$(SUFOBJ)) ;
	Objects $(>) ;
}

rule LibraryFromObjects
{
	# library depends on its member objects

	L = $(<:S=$(SUBLIB)) ;
	S = $(>) ;

	if $(SOURCE_GRIST)
	{
	    S = $(>:G=$(SOURCE_GRIST)) ;
	}

	DEPENDS lib : $(L) ;
	DEPENDS $(L) : $(L)($(S:BS)) ;

	Clean clean : $(L) ;

	# We wish we could locate the library and it's contents,
	# but the reference to $(NEEDLIBS) in Main's actions
	# get the unbound names.  Only $(<) and $(>) refer to
	# bound file name in rule actions.  Sigh.
	#
	# LOCATE on $(<) $(<)($(S:BS)) = $(LOCATE_TARGET) ;

	# each archive member object depends on real object
	# each real object gets compiled from sources

	for i in $(S)
	{
	    DEPENDS $(L)($(i:BS)) : $(i) ;
	}

	# must call separate Archive rule so that 'updated' modifier
	# on 'actions' refers to updated .o's.
	# delete objects after archive is made

	if $(CRELIB) { CreLib $(L) ; }

	Archive $(L) : $(S) ;
	RmTemps $(L) : $(S) ;

	if $(RANLIB) { Ranlib $(L) ; }
}

rule LinkLibraries
{
	# make library dependencies of target
	# set NEEDLIBS variable used by 'actions Main'

	T = $(<:S=$(SUFEXE)) ;

	DEPENDS $(T) : $(>:S=$(SUFLIB)) ;
	NEEDLIBS on $(T) += $(>:S=$(SUFLIB)) ;
}

rule Main
{
	MainFromObjects $(<) : $(>:S=$(SUFOBJ)) ;
	Objects $(>) ;
}

rule MainFromObjects
{
	# make compiled sources a dependency of target

	S = $(>) ;
	T = $(<:S=$(SUFEXE)) ;

	if $(SOURCE_GRIST)
	{
	    S = $(>:G=$(SOURCE_GRIST)) ;
	}

	DEPENDS exe : $(T) ;
	DEPENDS $(T) : $(S) ;
	LOCATE on $(T) = $(LOCATE_TARGET) ;

	Clean clean : $(T) ;

	Link $(T) : $(S) ;
}

rule Object
{
	# locate object and search for source, if wanted

	Clean clean : $(<) ;

	LOCATE on $(<) = $(LOCATE_TARGET) ;
	SEARCH on $(>) = $(SEARCH_SOURCE) ;

	# Save HDRS for -I$(HDRS) on compile.
	# We shouldn't need -I$(SEARCH_SOURCE) as cc can find headers
	# in the .c file's directory, but generated .c files (from
	# yacc, lex, etc) are located in $(LOCATE_TARGET), possibly
	# different from $(SEARCH_SOURCE).

	HDRS on $(<) = $(HDRS) $(SUBDIRHDRS) $(SEARCH_SOURCE) ;

	# handle #includes for source: Jam scans for headers with
	# the regexp pattern $(HDRSCAN) and then invokes $(HDRRULE)
	# with the scanned file as the target and the found headers
	# as the sources.  HDRSEARCH is just grist for HdrRule.

	HDRRULE on $(>) = HdrRule ;
	HDRSCAN on $(>) = $(HDRPATTERN) ;
	HDRSEARCH on $(>) = $(STDHDRS) $(HDRS) $(SUBDIRHDRS) $(SEARCH_SOURCE) ;

	# if source is not .c, generate .c with specific rule

	switch $(>:S)
	{
	    case .c :	Cc $(<) : $(>) ;
	    case .C :	c++ $(<) : $(>) ;
	    case .cc :	c++ $(<) : $(>) ;
	    case .cpp : c++ $(<) : $(>) ;
	    case .f :	Fortran $(<) : $(>) ;
	    case .l :	Cc $(<) : $(<:S=.c) ;
			Lex $(<:S=.c) : $(>) ;
	    case .s :	As $(<) : $(>) ;
	    case .y :	Cc $(<) : $(<:S=.c) ;
			Yacc $(<:S=.c) : $(>) ;
	    case * :	UserObject $(<) : $(>) ;
	}
}

rule ObjectCcFlags
{
	S = $(<:S=$(SUFOBJ)) ;

	if $(SOURCE_GRIST)
	{
	    S = $(S:G=$(SOURCE_GRIST)) ;
	}

	CCFLAGS on $(S) += $(>) ;
}

rule ObjectHdrs
{
	S = $(<:S=$(SUFOBJ)) ;

	if $(SOURCE_GRIST)
	{
	    S = $(S:G=$(SOURCE_GRIST)) ;
	}

	HDRS on $(S) += $(>) ;
}

rule Objects
{
	S = $(<) ;

	if $(SOURCE_GRIST)
	{
	    S = $(<:G=$(SOURCE_GRIST)) ;
	}

	for i in $(S)
	{
		Object $(i:S=$(SUFOBJ)) : $(i) ;
	}
}

rule RmTemps
{
	TEMPORARY $(>) ;
}

rule Setuid
{
	EXEMODE on $(<:S=$(SUFEXE)) = 4755 ;
}

rule Shell
{
	DEPENDS shell : $(<) ;
	DEPENDS $(<) : $(>) ;
	SEARCH on $(>) = $(SEARCH_SOURCE) ;
}

rule SubDir
{
	# This introduces a subdirectory Jamfile, setting up all the
	# search & locate stuff.
	#
	#	SubDir TOP d1 [ d2 [ d3 [ d4 ] ] ]
	#
	# TOP is the name of the (environment) variable that names the
	# TOP level directory of the build tree.  d1...d4 are the
	# directory elements that lead to this directory.  The call
	# to SubDir is system independent, in that it contains no OS
	# path!	 We crudely construct the path below.

	if ! $($(<[1]))
	{
	    ECHO Top level of source tree has not been set with $(<[1]) ;
	}

	# Get the grist $(g), search $(s)
	# This is just hideous variable manipulation

	g = $(<[2]) ;
	s = $(SLASH)$(<[2]) ;

	for i in $(<[3-])
	{
	    g = $(g)!$(i) ;
	    s = $(s)$(SLASH)$(i) ;
	}

	# Now set up SEARCH_SOURCE, LOCATE_TARGET, SOURCE_GRIST
	# These can be reset if needed.	 For example, if the source
	# directory should not hold object files, LOCATE_TARGET can
	# subsequently be redefined.

	SUBDIR = $($(<[1]))$(s) ;
	SEARCH_SOURCE = $(SUBDIR) ;
	LOCATE_TARGET = $(SUBDIR) ;
	SOURCE_GRIST = $(g) ;

	# Reset per-directory ccflags, hdrs

	SUBDIRCCFLAGS = ;
	SUBDIRHDRS = ;
}

rule SubDirCcFlags
{
	SUBDIRCCFLAGS += $(<) ;
}

rule SubDirHdrs
{
	SUBDIRHDRS += $(<) ;
}

rule SubInclude
{
	# That's
	#	SubInclude TOP d1 [ d2 [ d3 [ d4 ] ] ]
	#
	# to include a subdirectory's Jamfile.

	if ! $($(<[1]))
	{
	    ECHO Top level of source tree has not been set with $(<[1]) ;
	}

	s = "" ;

	for i in $(<[2-])
	{
	    s = $(s)$(SLASH)$(i) ;
	}

	include $($(<[1]))$(s)$(SLASH)$(JAMFILE) ;
}

rule Undefines
{
	UNDEFS on $(<:S=$(SUFEXE)) += $(UNDEFFLAG)$(>) ;
}

rule UserObject
{
	ECHO "Unknown suffix on" $(>) "- see UserObject rule in Jambase(5)." ;
}

rule Yacc
{
	h = $(<:BS=.h) ;

	# Some places don't have a yacc.

	if $(YACC)
	{
	    DEPENDS $(<) $(h) : $(>) ;
	    Yacc1 $(<) $(h) : $(>) ;
	    Clean clean : $(<) $(h) ;
	}

	# make sure someone includes $(h) else it will be
	# a deadly independent target

	INCLUDES $(<) : $(h) ;
	LOCATE on $(<) $(h) = $(LOCATE_TARGET) ;
}

#
# Actions
#

if $(UNIX)
{

    actions updated together piecemeal Archive
    {
	$(AR) $(<) $(>)
    }

    actions As
    {
	$(AS) $(ASFLAGS) -o $(<) $(>) ;
    }

    actions C++
    {
	$(C++) -c $(C++FLAGS) $(OPTIM) -I$(HDRS) -o $(<) $(>)
    }

    actions Cc
    {
	$(CC) -c $(CCFLAGS) $(OPTIM) -I$(HDRS) -o $(<) $(>)
    }

    actions piecemeal together existing Clean
    {
	$(RM) $(>)
    }

    actions File
    {
	$(RM) $(<)
	$(CP) $(>) $(<) &&
	$(CHMOD) $(FILEMODE) $(<)
    }

    actions Fortran
    {
	$(FORTRAN) $(FORTRANFLAGS) -o $(<) $(>)
    }

    actions HardLink
    {
	$(RM) $(<) && $(LN) $(>) $(<)
    }

    if $(INSTALL)
    {
	actions Install
	{
	$(INSTALL) -m $(INSTALLMODE) $(>) $(<)
	}
    }
    else
    {
	actions Install
	{
	[ -d "$(<:D)" ] || $(MKDIR) $(<:D)
	$(CP) $(>) $(<) &&
	$(CHMOD) $(INSTALLMODE) $(<)
	}
    }

    actions Lex
    {
	$(LEX) $(>) && $(MV) lex.yy.c $(<)
    }

    actions Link
    {
	if $(LINK) $(LINKFLAGS) -o $(<) $(UNDEFS) $(>) $(NEEDLIBS) $(LINKLIBS)
	then $(CHMOD) $(EXEMODE) $(<)
	else $(RM) $(<); exit 1
	fi
    }

    actions CcMv
    {
	[ $(<) != $(>:BS=$(SUFOBJ)) ] && $(MV) $(>:BS=$(SUFOBJ)) $(<)
    }

    actions together Ranlib
    {
	$(RANLIB) $(<)
    }

    actions quietly updated piecemeal together RmTemps
    {
	$(RM) $(>)
    }

    actions Shell
    {
	awk '
		NR == 1 { print "$(SHELLHEADER)" }
		NR == 1 && /^[#:]/ { next }
		/^##/ { next }
		{ print }
	' < $(>) > $(<) && $(CHMOD) $(SHELLMODE) $(<)
    }

    actions Yacc1
    {
	$(YACC) $(>) &&
	{
	    $(MV) y.tab.c $(<[1])
	    $(MV) y.tab.h $(<[2])
	}
    }
}
else if $(NT)
{
    if $(BCCROOT)
    {
	actions Link
	{
	$(LINK) -e$(<) $(LINKFLAGS) $(UNDEFS) -L$(LINKLIBS) $(NEEDLIBS) $(>) || del $(<) /f
	}

	actions together piecemeal Archive
	{
	$(AR) $(ARFLAGS) $(<) -+$(>)
	}
    }
    else if $(MSVCNT)
    {
	actions Link
	{
	$(LINK) $(LINKFLAGS) /o$(<) $(UNDEFS) $(>) $(NEEDLIBS) $(LINKLIBS)
	}

	actions together piecemeal Archive
	{
	$(AR) /out:$(<) $(>)
	}
    }

    actions Cc
    {
	$(CC) /c $(CCFLAGS) $(OPTIM) /out:$(<) /I$(HDRS) $(>)
    }

    actions piecemeal together existing Clean
    {
	$(RM) $(>) /f /q
    }

    actions File
    {
	copy $(>) $(<)
    }

    actions quietly updated piecemeal together RmTemps
    {
	$(RM) $(>)
    }
}
else if $(VMS)
{

    actions updated together piecemeal Archive 
    {
	lib/replace $(<) $(>[1]) ,$(>[2-])
    }

    actions Cc
    { 
	cc/obj=$(<) $(CCFLAGS) $(OPTIM) $(SLASHINC) $(>) 
    }

    actions piecemeal together existing Clean
    {
	$(RM) $(>[1]);* ,$(>[2-]);*
    }

    actions together quietly CreLib
    {
       if f$search("$(<)") .eqs. "" then lib/create $(<)
    }

    actions File
    {
	copy $(>) $(<)
	set file/prot=$(FILEMODE) $(<)
    }

    actions Install
    {
	copy $(>) $(<)
	set file/prot=$(INSTALLMODE) $(<)
    }

    actions Lex
    {
	$(LEX) $(>) 
	$(MV) lex.yy.c $(<)
    }

    actions Link 
    {
	$(LINK)/exe=$(<) $(LINKFLAGS) $(>[1]) ,$(>[2-]) ,$(NEEDLIBS)/lib ,$(LINKLIBS)
	set file/prot=$(EXEMODE) $(<)
    }

    actions quietly updated piecemeal together RmTemps
    {
	$(RM) $(>[1]);* ,$(>[2-]);*
    }

    actions Shell
    {
	copy $(>) $(<)
	set file/prot=$(SHELLMODE) $(<)
    }

    actions Yacc1
    {
	$(YACC) $(>)
	$(MV) y.tab.c $(<[1])
	$(MV) y.tab.h $(<[2])
    }
}


#
# Backwards compatibility with jam 1, where rules were uppercased.
#

rule BULK { Bulk $(<) : $(>) ; }
rule FILE { File $(<) : $(>) ; }
rule HDRRULE { HdrRule $(<) : $(>) ; }
rule INSTALL { Install $(<) : $(>) ; }
rule LIBRARY { Library $(<) : $(>) ; }
rule LIBS { LinkLibraries $(<) : $(>) ; }
rule LINK { Link $(<) : $(>) ; }
rule MAIN { Main $(<) : $(>) ; }
rule SETUID { Setuid $(<) ; }
rule SHELL { Shell $(<) : $(>) ; }
rule UNDEFINES { Undefines $(<) : $(>) ; }

# Old INSTALL* didn't take dest directory.

rule INSTALLBIN { InstallBin $(BINDIR) : $(<) ; }
rule INSTALLLIB { InstallLib $(LIBDIR) : $(<) ; }
rule INSTALLMAN { InstallMan $(MANDIR) : $(<) ; }

#
# Now include the user's Jam rules and Jamfile.
#

include $(JAMUSER) ;
include $(JAMFILE) ;

