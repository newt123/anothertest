#
# /+\
# +\	Copyright 1993 Christopher Seiwald.
# \+/
#

#
# JAMBASE - jam ruleset providing make(1)-like functionality
#
# 12/27/93 (seiwald) - purturb library sources with SOURCE_GRIST
# 04/18/94 (seiwald) - use 'default =' when setting OS specific vars
# 04/21/94 (seiwald) - do RmTemps together 
# 05/05/94 (seiwald) - all supported C compilers support -o: relegate
#		       RELOCATE as an option; set Ranlib to "" to disable it
# 06/01/94 (seiwald) - new 'actions existing' to do existing sources
# 08/25/94 (seiwald) - new CcAddFlags rule to append to per-target CCFLAGS
# 08/29/94 (seiwald) - new CcAddHdrs rule to append to per-target HDRS
# 09/19/94 (seiwald) - LinkLibraries and Undefs now append
# 		     - Rule names downshifted.
# 10/06/94 (seiwald) - Dumb yyacc stuff moved into Jamfile.
# 10/14/94 (seiwald) - (Crude) support for .s, .C, .cc, .cpp, and .f files.
# 01/08/94 (seiwald) - Shell now handled with awk, not sed

# Rules defined by this file:
#
# as obj.o : source.s ;			.s -> .o
# Bulk dir : files ;			populate directory with many files
# Cc obj.o : source.c ;			.c -> .o
# C++ obj.o : source.cc ;		.cc -> .o
# CcAddFlags source : flags ;		add compiler flags for object
# CcAddHdrs source : dirs ;		add include directories for object
# Clean clean : sources ;		remove sources with 'jam clean'
# File dest : source ;			copy file
# Fortran obj.o : source.f ;		.f -> .o
# Hardlink target : source ;		make link from source to target
# HdrRule source : headers ;		handle #includes
# Install target : source ;		install any single file
# InstallBin sources ;			install binaries
# InstallLib sources ;			install files
# InstallMan source ;			install man pages
# InstallShell source ;			install shell script
# Lex source.c : source.l ;		.l -> .c
# Library lib : source ;		archive library from compiled sources
# LibraryFromObjects lib : objects ;	archive library from objects
# LinkLibraries image : libraries ;	bag libraries onto a Main
# Main image : source ;			link executable from compiled sources
# MainFromObjects image : objects ;	link executable from objects
# Object object : source ;		compile object from source
# Objects sources ;			compile sources
# RmTemps target : sources ;		remove temp sources after target made
# Setuid image ;			mark an executable Setuid
# Shell exe : source ;			make a shell executable
# Undefines image : symbols ;		save undef's for linking
# UserObject object : source ;		handle unknown suffixes for Object
# Yacc source.c : source.y ; 		.y -> .c
#

# Brief review of the jam language:
#
# Statements:
#	rule RULE - statements to process a rule
#	actions RULE - system commands to carry out target update
#
# Modifiers on actions:
#	together - multiple instances of same rule on target get executed
#		   once with their sources ($(>)) concatenated
#	updated - refers to updated sources ($(>)) only
#	ignore - ignore return status of command
#	quietly - don't trace its execution unless verbose
#	piecemeal - iterate command each time with a small subset of $(>)
#	existing - refers to currently existing sources ($(>)) only
#
# Special rules:
#	DEPENDS - builds the dependency graph
#	ECHO - blurt out targets on stdout
#	INCLUDES - marks sources as headers for target (a codependency)
#	NOCARE - don't panic if the target can't be built
#	NOTFILE - ignore the timestamp of the target (it's not a file)
#	TEMPORARY - target need not be present if sources haven't changed
#
# Special variables set by jam:
#	$(<) - targets of a rule (to the left of the :)
#	$(>) - sources of a rule (to the right of the :)
#	$(UNIX) - true on UNIX
#	$(VMS) - true on VMS
#	$(OS) - name of OS - varies wildly
#
# Special variables used by jam:
#	SEARCH - where to find something (used during binding and actions)
#	LOCATE - where to plop something not found with SEARCH
#	HDRRULE - rule to call to handle include files
#	HDRSCAN - egrep regex to extract include files
#
# Special targets:
#	all - default if none given on command line

# Initialize variables
#
# "default =" - set only if unset

#
# OS specific variable settings
#

switch $(OS) 
{
case AIX :	LINKLIBS default = -lbsd ;
case DGUX :	RANLIB default = "" ;
case IRIX :	RANLIB default = "" ;
case HPUX :	RANLIB default = "" ;
case PTX :	RANLIB default = "" ;
case SOLARIS :	RANLIB default = "" ;
}

AR 		default = ar ru ;
AS		default = as ;
ASFLAGS		default = ;
BINDIR		default = /usr/local/bin ;
C++		default = gcc ;
C++FLAGS	default = ;
CC 		default = cc ;
CCFLAGS 	default = ;
CHMOD 		default = chmod ;
EXEMODE 	default = 711 ;
FILEMODE 	default = 644 ;
FORTRAN		default = f77 ;
FORTRANFLAGS	default = ;
HDRS 		default = ;
INSTALL		default = install ;
JAMFILE		default = Jamfile ;
JAMRULES	default = ;
LEX		default = lex ;
LIBDIR		default = /usr/local/lib ;
LINK 		default = $(CC) ;
LINKFLAGS 	default = $(CCFLAGS) ;
LINKLIBS 	default = ;
LN		default = ln ;
MANDIR		default = /usr/local/man ;
MV 		default = mv -f ;
OPTIM		default = -O ;
RANLIB 		default = ranlib ;
RM 		default = rm -f ;
SHELLHEADER 	default = "#!/bin/sh" ;
SHELLMODE 	default = 755 ;
STDHDRS 	default = /usr/include ;
UNDEFFLAG	default = "-u _" ;
YACC 		default = yacc -d ;

HDRPATTERN = "^#[ 	]*include[ 	]*[<\"](.*)[\">].*$" ;

#
# Base dependencies - first for "bootstrap" kinds of rules
#

DEPENDS all : first shell files lib exe ;
NOTFILE all first shell files lib exe ;

#
# Compiling and linking rules.
#

rule Main 
{
	MainFromObjects $(<) : $(>:S=.o) ;
	Objects $(>) ;
}

rule MainFromObjects
{
	# make compiled sources a dependency of target

	S = $(>) ;

	if $(SOURCE_GRIST)
	{
	    S = $(>:G=$(SOURCE_GRIST)) ;
	}

	DEPENDS exe : $(<) ;
	DEPENDS	$(<) : $(S) ;
	LOCATE on $(<) = $(LOCATE_TARGET) ;

	Clean clean : $(<) ;

	Link $(<) : $(S) ;
}

actions Link 
{
	if $(LINK) $(LINKFLAGS) -o $(<) $(UNDEFS) $(>) $(NEEDLIBS) $(LINKLIBS) 
	then chmod $(EXEMODE) $(<) 
	else $(RM) $(<); exit 1
	fi
}

rule LinkLibraries 
{
	# make library dependencies of target
	# set NEEDLIBS variable used by 'actions Main'

	DEPENDS $(<) : $(>) ;
	NEEDLIBS on $(<) += $(>) ;
}

rule Undefines
{
	UNDEFS on $(<) += $(UNDEFFLAG)$(>) ;
}

rule Setuid
{
	EXEMODE on $(<) = 4755 ;
}

rule Library
{
	LibraryFromObjects $(<) : $(>:S=.o) ;
	Objects $(>) ;
}

rule LibraryFromObjects
{
	# library depends on its member objects

	S = $(>) ;

	if $(SOURCE_GRIST)
	{
	    S = $(>:G=$(SOURCE_GRIST)) ;
	}

	DEPENDS lib : $(<) ;
	DEPENDS $(<) : $(<)($(S:BS)) ;

	Clean clean : $(<) ;

	# We wish we could locate the library and it's contents,
	# but the reference to $(NEEDLIBS) in Main's actions
	# get the unbound names.  Only $(<) and $(>) refer to
	# bound file name in rule actions.  Sigh.
	# 
	# LOCATE on $(<) $(<)($(S:BS)) = $(LOCATE_TARGET) ;

	# each archive member object depends on real object
	# each real object gets compiled from sources

	for i in $(S) 
	{
	    DEPENDS $(<)($(i:BS)) : $(i) ; 
	}

	# must call separate Archive rule so that 'updated' modifier
	# on 'actions' refers to updated .o's.
	# delete objects after archive is made

	Archive $(<) : $(S) ;
	RmTemps $(<) : $(S) ;

	if $(RANLIB) { Ranlib $(<) ; }
}

actions updated together piecemeal Archive 
{
	$(AR) $(<) $(>)
}

actions together Ranlib
{
	$(RANLIB) $(<)
}

rule RmTemps
{
	TEMPORARY $(>) ;
}

actions quietly updated piecemeal together RmTemps
{
	$(RM) $(>)
}

rule Objects
{
	S = $(<) ;

	if $(SOURCE_GRIST)
	{
	    S = $(<:G=$(SOURCE_GRIST)) ;
	}

	for i in $(S) 
	{ 
		Object $(i:S=.o) : $(i) ;
	}
}

rule Object 
{
	# locate object and search for source, if wanted

	Clean clean : $(<) ;

	LOCATE on $(<) = $(LOCATE_TARGET) ;
	SEARCH on $(>) = $(SEARCH_SOURCE) ;

	# Save HDRS for -I$(HDRS) on compile.
	# We shouldn't need -I$(SEARCH_SOURCE) as cc can find headers 
	# in the .c file's directory, but generated .c files (from 
	# yacc, lex, etc) are located in $(LOCATE_TARGET), possibly 
	# different from $(SEARCH_SOURCE).

	HDRS on $(<) = $(HDRS) $(SEARCH_SOURCE) ;

	# handle #includes for source: Jam scans for headers with
	# the regexp pattern $(HDRSCAN) and then invokes $(HDRRULE)
	# with the scanned file as the target and the found headers
	# as the sources.  HDRSEARCH is just grist for HdrRule.

	HDRRULE on $(>) = HdrRule ;
	HDRSCAN on $(>) = $(HDRPATTERN) ;
	HDRSEARCH on $(>) = $(HDRS) $(STDHDRS) $(SEARCH_SOURCE) ;

	# if source is not .c, generate .c with specific rule

	switch $(>:S)
	{
	    case .c : 	Cc $(<) : $(>) ;
	    case .C :	c++ $(<) : $(>) ;
	    case .cc :	c++ $(<) : $(>) ;
	    case .cpp :	c++ $(<) : $(>) ;
	    case .f :	Fortran $(<) : $(>) ;
	    case .l :	Cc $(<) : $(<:S=.c) ;
			Lex $(<:S=.c) : $(>) ;
	    case .s :	As $(<) : $(>) ;
	    case .y : 	Cc $(<) : $(<:S=.c) ; 
			Yacc $(<:S=.c) : $(>) ;
	    case * :	UserObject $(<) : $(>) ;
	}
}

rule UserObject
{
	ECHO "Unknown source file suffix on" $(>) "-"
		"try defining your own UserObject rule." ;
}

rule HdrRule
{
	# HdrRule source : headers ;

	# N.B.  This rule is called during binding, potentially after 
	# the fate of many targets has been determined, and must be 
	# used with caution: don't add dependencies to unrelated 
	# targets, and don't set variables on $(<).

	# Tell Jam that anything depending on $(<) also depends on $(>), 
	# set SEARCH so Jam can find the headers, but then say we don't
	# care if we can't actually find the headers (they may have been 
	# within ifdefs), 

	INCLUDES $(<) : $(>) ;
	SEARCH on $(>) = $(HDRSEARCH) ;
	NOCARE $(>) ;

	# Propagate on $(<) to $(>)

	HDRSEARCH on $(>) = $(HDRSEARCH) ;
	HDRSCAN on $(>) = $(HDRSCAN) ;
	HDRRULE on $(>) = $(HDRRULE) ;
}

rule As
{
	DEPENDS $(<) : $(>) ;
}

actions As
{
	$(AS) $(ASFLAGS) -o $(<) $(>) ;
}

rule CcAddFlags
{
	S = $(<:S=.o) ;

	if $(SOURCE_GRIST)
	{
	    S = $(S:G=$(SOURCE_GRIST)) ;
	}

	CCFLAGS on $(S) += $(>) ;
}

rule CcAddHdrs
{
	S = $(<:S=.o) ;

	if $(SOURCE_GRIST)
	{
	    S = $(S:G=$(SOURCE_GRIST)) ;
	}

	HDRS on $(S) += $(>) ;
}

rule Cc
{
	DEPENDS $(<) : $(>) ;

	if $(RELOCATE)
	{
	    "Cc -mv" $(<) : $(>) ;
	}
	else
	{
	    "Cc -o" $(<) : $(>) ;
	}

	# Just to clarify here: this sets the per-target CCFLAGS to
	# be the current value of (global) CCFLAGS and CCDIRFLAGS.

	CCFLAGS on $(<) += $(CCFLAGS) $(CCDIRFLAGS) ;
}

actions "Cc -o"
{
	$(CC) -c $(CCFLAGS) $(OPTIM) -I$(HDRS) -o $(<) $(>)
}

actions "Cc -mv"
{
	$(CC) -c $(CCFLAGS) $(OPTIM) -I$(HDRS) $(>)
	[ $(<) != $(<:D=) ] && $(MV) $(<:D=) $(<)
}

rule C++
{
	DEPENDS $(<) : $(>) ;
}

actions C++
{
	$(C++) -c $(C++FLAGS) $(OPTIM) -I$(HDRS) -o $(<) $(>)
}

rule Fortran
{
	DEPENDS $(<) : $(>) ;
}

actions Fortran
{
	$(FORTRAN) $(FORTRANFLAGS) -o $(<) $(>)
}

rule Lex
{
	DEPENDS $(<) : $(>) ;
	LOCATE on $(<) = $(LOCATE_TARGET) ;
	Clean clean : $(<) ;
}

actions Lex
{
	$(LEX) $(>) && $(MV) lex.yy.c $(<)
}

rule Yacc 
{
	h = $(<:BS=.h) ;

	DEPENDS $(<) $(h) : $(>) ;
	Yacc1 $(<) $(h) : $(>) ;
	Clean clean : $(<) $(h) ;
	# make sure someone includes $(h) else it will be
	# a deadly independent target
	INCLUDES $(<) : $(h) ;
	LOCATE on $(<) $(h) = $(LOCATE_TARGET) ;
}

actions Yacc1
{
	$(YACC) $(>) &&
	{
	    $(MV) y.tab.c $(<[1])
	    $(MV) y.tab.h $(<[2])
	}
}

# 
# File copying/installing/linking rules.
#

rule Bulk 
{
	for i in $(>) 
	{ 
	    File $(i:D=$(<)) : $(i) ; 
	}
}

rule File
{
	DEPENDS files : $(<) ;
	DEPENDS $(<) : $(>) ;
	SEARCH on $(>) = $(SEARCH_SOURCE) ;
}

actions File
{
	$(RM) $(<)
	cp $(>) $(<) &&
	chmod $(FILEMODE) $(<)
}

rule HardLink
{
	DEPENDS files : $(<) ;
	DEPENDS $(<) : $(>) ;
	SEARCH on $(>) = $(SEARCH_SOURCE) ;
}

actions HardLink
{
	$(RM) $(<) && $(LN) $(>) $(<)
}

rule Shell
{
	DEPENDS shell : $(<) ;
	DEPENDS $(<) : $(>) ;
	SEARCH on $(>) = $(SEARCH_SOURCE) ;
}

actions Shell
{
	awk '
		NR == 1 { print "$(SHELLHEADER)" }
		NR == 1 && /^[#:]/ { next }
		/^##/ { next }
		{ print }
	' < $(>) > $(<)

	chmod $(SHELLMODE) $(<)
}

rule InstallBin
{
	for i in $(<)
	{
	    Install $(i:D=$(BINDIR)) : $(i) ;
	    INSTALLMODE on $(i:D=$(BINDIR)) = $(EXEMODE) ;
	}
}

rule InstallLib
{
	for i in $(<) 
	{
	    Install $(i:D=$(LIBDIR)) : $(i) ;
	    INSTALLMODE on $(i:D=$(LIBDIR)) = $(FILEMODE) ;
	}
}

rule InstallLibDir
{
	INSTALLLIBDIR = $(<) ;
}

rule InstallMan
{
	# Really this just strips the . from the suffix

	for i in $(<)
	{
	    switch $(i:S)
	    {
	    case .1 : S = 1 ; case .2 : S = 2 ; case .3 : S = 3 ; 
	    case .4 : S = 4 ; case .5 : S = 5 ; case .6 : S = 6 ; 
	    case .7 : S = 7 ; case .8 : S = 8 ; case .l : S = l ; 
	    case .n : S = n ; case .man : S = 1 ;
	    }

	    D = $(i:D=$(MANDIR)/man$(S):S=.$(S)) ;

	    Install $(D) : $(i) ;
	    INSTALLMODE on $(D) = $(FILEMODE) ;
	}
}

rule InstallShell
{
	for i in $(<) 
	{
	    Install $(i:D=$(BINDIR)) : $(i) ;
	    INSTALLMODE on $(i:D=$(BINDIR)) = $(SHELLMODE) ;
	}
}

rule Install
{
	DEPENDS install : $(<) ;
	DEPENDS $(<) : $(>) ;
	SEARCH on $(>) = $(SEARCH_SOURCE) ;
}

if $(INSTALL)
{
    actions Install
    {
	    $(INSTALL) -m $(INSTALLMODE) $(>) $(<)
    }
}
else
{
    actions Install
    {
	    [ -d "$(<:D)" ] || mkdir $(<:D)
	    cp $(>) $(<) &&
	    chmod $(INSTALLMODE) $(<) 
    }
}

actions piecemeal together existing Clean
{
	rm -f $(>)
}

#
# Multidirectory support.
#

rule SubDir
{
	# Just a reminder here:
	#	SubDir TOP d1 [ d2 [ d3 [ d4 ] ] ]
	#
	# TOP is the name of the (environment) variable that names the 
	# TOP level directory of the build tree.  d1...d4 are the
	# directory elements that lead to this directory.  The call
	# to SubDir is system independent, in that it contains no OS
	# path!

	if ! $($(<[1])) 
	{
	    ECHO Top level of source tree has not been set with $(<[1]) ;
	}

	# Get the grist, search
	# This is just hideous variable manipulation

	if $(<[5]) { 
		g = $(<[2])!$(<[3])!$(<[4])!$(<[5]) ;
		s = /$(<[2])/$(<[3])/$(<[4])/$(<[5]) ;
	} else if $(<[4]) {
		g = $(<[2])!$(<[3])!$(<[4]) ;
		s = /$(<[2])/$(<[3])/$(<[4]) ;
	} else if $(<[3]) {
		g = $(<[2])!$(<[3]) ;
		s = /$(<[2])/$(<[3]) ;
	} else if $(<[2]) {
		g = $(<[2]) ;
		s = /$(<[2]) ;
	} else {
		g = ;
		s = ;
	}

	# Now set up SEARCH_SOURCE, LOCATE_TARGET, SOURCE_GRIST

	SEARCH_SOURCE = $($(<[1]))$(s) ;
	LOCATE_TARGET = $($(<[1]))$(s) ;
	SOURCE_GRIST = $(g) ;
	CCDIRFLAGS = ;
}

rule SubInclude
{
	# That's
	#	SubInclude TOP d1 [ d2 [ d3 [ d4 ] ] ]

	if ! $($(<[1])) 
	{
	    ECHO Top level of source tree has not been set with $(<[1]) ;
	}

	if $(<[5]) { 
		include $($(<[1]))/$(<[2])/$(<[3])/$(<[4])/$(<[5])/$(JAMFILE) ;
	} else if $(<[4]) {
		include $($(<[1]))/$(<[2])/$(<[3])/$(<[4])/$(JAMFILE) ;
	} else if $(<[3]) {
		include $($(<[1]))/$(<[2])/$(<[3])/$(JAMFILE) ;
	} else if $(<[2]) {
		include $($(<[1]))/$(<[2])/$(JAMFILE) ;
	}
}

#
# Backwards compatibility with jam 1, where rules were uppercased.
#

rule BULK { Bulk $(<) : $(>) ; }
rule FILE { File $(<) : $(>) ; }
rule HDRRULE { HdrRule $(<) : $(>) ; }
rule INSTALL { Install $(<) : $(>) ; }
rule INSTALLBIN { InstallBin $(<) : $(>) ; }
rule INSTALLLIB { InstallLib $(<) : $(>) ; }
rule INSTALLMAN { InstallMan $(<) : $(>) ; }
rule LIBRARY { Library $(<) : $(>) ; }
rule LIBS { LinkLibraries $(<) : $(>) ; }
rule LINK { Link $(<) : $(>) ; }
rule MAIN { Main $(<) : $(>) ; }
rule SETUID { Setuid $(<) ; }
rule SHELL { Shell $(<) : $(>) ; }
rule UNDEFINES { Undefines $(<) : $(>) ; }

#
# Now include the user's Jam rules and Jamfile.
# 

include $(JAMRULES) ;
include $(JAMFILE) ;

