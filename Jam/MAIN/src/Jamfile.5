.TH JAMFILE 5 "15 January 1995"
.de BB
.RS
.PP
.ft CW
.na
.nf
..
.de BE
.RE
.ft R
.fi
.ad
..
.de XB
Example:
.BB
..
.de XE
.BE
..
.SH NAME
\fBJamfile\fR \- per-directory \fBjam\fR(1) instructions
.SH DESCRIPTION
.PP
\fBJamfile\fR is the file that tells the build tool \fBjam\fR what to
do in the current directory.  This man page gives examples for a
\fBJamfile\fR.
.PP
The rules used here are defined by \fBJambase\fR, the \fBjam\fR
boilerplate.  \fBJambase\fR contains a set of \fBjam\fR rule
definitions that provide the roughly \fBmake\fR(1)-like functionality
shown here.
.SH WHITESPACE NOTE
.PP
\fBJam\fR requires whitespace (blanks, tabs, or newlines) to surround
all tokens, including the \fB:\fR (colon) and \fB;\fR (semicolon)
tokens.  This is because \fBjam\fR runs on many platforms and no
characters, save whitespace, are uncommon in the file names on all of
those platforms.
.SH EXECUTABLES AND LIBRARIES
.SS Main Rule
.PP
The \fIMain\fR rule handles the compiling of one or more files and linking
the resulting objects into an executable.
.XB
Main myprog : main.c util.c ;
.XE
.PP
This compiles main.c and util.c and links main.o and util.o into myprog.
.SS Library Rule
.PP
The \fILibrary\fR rule handles the compiling of one or more sources,
archiving the resulting objects, and then deleting the objects.
.XB
Library libstring.a : strcmp.c strcpy.c strlen.c ;
Library libtree.a : treemake.c treetrav.c ;
.XE
.SS LinkLibraries Rule
.PP
To link executables against libraries that are built, indicate this
with the \fILinkLibraries\fR rule.
.XB
Main myprog : main.c util.c ;
LinkLibraries myprog : libstring.a libtree.a ;

Library libstring.a : strcmp.c strcpy.c strlen.c ;
Library libtree.a : treemake.c treetrav.c ;
.XE
.PP
The ordering of the lines above is not critical.
.SS Variables
.PP
The following variables control the linking of executables and the
archiving of libraries.
.BB
AR              archive command (ar ru)
EXEMODE         permission set on executable after linking (711)
LINK            linker command (cc)
LINKFLAGS       linker flags ()
LINKLIBS        additional libraries that aren't dependents ()
RANLIB          name of ranlib program, if any (ranlib)
.BE
.PP
The difference between and the arguments to \fILinkLibraries\fR
and the value of $(LINKLIBS) is that the former are expected to be
real, buildable libraries, while the latter are just handed without
inspection to the $(LINK) command.  The ordering on the $(LINK)
command line is first \fILinkLibraries\fR, then $(LINKLIBS).
.XB
Main xprog : xprog.c ;
LinkLibraries xprog : libxutil.a ;
LINKFLAGS on xprog = -Bstatic ;
LINKLIBS on xprog = -lXext -lX11 ;

Library libxutil.a : xtop.c xbottom.c xutil.c ;
.XE
.SH COMPILING
.SS Objects Rule
.PP
Compiling occurs normally as a byproduct of \fIMain\fR or \fILibrary\fR
calling the \fIObjects\fR rule on the source files.  \fIObjects\fR can be
called directly.
.XB
Objects a.c b.c c.c ;
.XE
.PP
This compiles a.c into a.o, b.c into b.o, etc.
.SS Object Rule
.PP
\fIObjects\fR gets its work done by calling the \fIObject\fR rule on
each of the source files, assuming that the object name itself will be
the source file name, with the suffix replaced appropriately.  To compile
a single source file directly, use the \fIObject\fR rule.
.XB
Object foo.o : foo.c ;
.XE
.PP
The \fIObject\fR rule doesn't require that the object name bear any
relationship to the source.  It is thus possible to compile the same
file into different objects.
.XB
Object a.o : foo.c ;
Object b.o : foo.c ;
Object c.o : foo.c ;
.XE
.PP
This compiles foo.c (three times) into a.o, b.o, and c.o.  Later examples
show how this is useful.
.PP
The \fIObject\fR rule looks at the suffix of the source file and calls
the appropriate rules to do the actual compiling.  This invariably
involves a call to the \fICc\fR to turn the .c into a .o, but may also
require a call to other rules to turn the source file into a .c. 
Thus the \fIObject\fR rule is responsible for the generation of an
object file from any type of source.
.XB
Object grammar.o : grammar.y ;
Object scanner.o : scanner.l ;
Object fastf.o : fastf.f ;
Object util.o : util.c ;
.XE
.PP
In addition to calling the compiling rule, \fIObject\fR sets up a bunch
of variables specific to the source and target files.  These are discussed
below.
.SS Cc, C++, Yacc, Lex, Fortran, As, etc. Rules
.PP
The \fIObject\fR calls compiling rules specific to the suffix of the
source file.  Because the extra work done by the \fIObject\fR rule, it
is not always useful to call the compiling rules directly.  But the
adventurous user might attempt it.  
.XB
Yacc grammar.c : grammar.y ;
Lex scan.c : scan.l ;
Cc prog.o : prog.c ;
.XE
.PP
These examples individually run \fByacc\fR(1), \fBlex\fR(1), and the
C compiler on their sources.
.SS UserObject Rule
Any files with suffixes not understood by the \fIObject\fR rule are
passed to the \fIUserObject\fR rule.  The default definition of
\fIUserObject\fR simply emits a warning that the suffix is not understood.
This rule definition is intended to be replaced with a one that
recognises the suffix.  
.XB
rule UserObject
{
    switch $(>)
    {
    case *.s    : As $(<) : $(>) ;
    case *      : ECHO "unknown suffix on" $(>) ;
    }
}

rule As
{
    DEPENDS $(<) : $(>) ;
}

actions As
{
    as -o $(<) $(>)
}

Library libsys.a : alloca.s memcpy.s ;
.XE
.PP
It should be mentioned that this example is contrived, in that the \fB.s\fR 
suffix is already handled by \fIObject\fR.
.SS Variables
.PP
The following variables control the compiling of source files.
.BB
CC              The C Compiler (cc)
C++             The C++ Compiler (gcc)
CCFLAGS         C compiler flags()
C++FLAGS        C++ compiler flags()
HDRS            non-standard header directories ()
LEX             The Lex program (lex)
OPTIM           optimization flag, if desired (-O)
STDHDRS         standard header directories (/usr/include)
YACC            The Yacc program (yacc -d)
.BE
.PP
$(CC), $(C++), $(CCFLAGS), $(C++FLAGS), $(OPTIM), and $(HDRS) all affect 
the compiling of C and C++ files.  $(OPTIM) is separate from $(CCFLAGS)
and $(C++FLAGS) so they can be set separately.
.PP
$(HDRS) lists the directories to search for header files, and it is
used in two ways: first, it is passed to the C compiler (with the 
flag \fB-I\fR prepended); second, it is used by \fIHdrRule\fR
to locate the header files whose names were found when scanning source
files.  $(STDHDRS) lists the header directories that the C compiler
knows about:  it is not passed to the C compiler, but is used by
\fIHdrRule\fR.
.PP
Note that these flags, if set as target-specific variables, must be
set on the target - the object file - not the source file.
.XB
Library libximage.a : xtiff.c xjpeg.c xgif.c ;

HDRS on xjpeg.o = /usr/local/src/jpeg ;
CCFLAGS on xtiff.o = -DHAVE_TIFF ;
.XE
.SS ObjectCcFlags, ObjectC++Flags, ObjectHdrs Rules
.PP
$(CCFLAGS), $(C++FLAGS) and $(HDRS) can be manipulated directly, but there are 
rules that allow these variables to be set by referring to the original
source file name, rather than to the derived object file name.
\fIObjectCcFlags\fR adds object-specific flags to the $(CCFLAGS) variable,
\fIObjectC++Flags\fR adds object-specific flags to the $(C++FLAGS) variable,
and \fIObjectHdrs\fR add object-specific directories to the $(HDRS)
variable.
.XB
Main xviewer : viewer.c ;
ObjectCcFlags viewer.c : -DXVERSION ;
ObjectHdrs viewer.c : /usr/include/X11 ;
.XE
.PP
Actually, the file suffix (\fB.c\fR in this case) is ignored: the
rules know to refer to the object.
.SH HEADER FILE PROCESSING
.PP
One of the functions of the \fIObject\fR rule is to scan source files
for (C style) header file inclusions.  To do so, it sets the
Jam-special variables $(HDRSCAN) and $(HDRRULE) (specifically for the
source file).  The presence of these variables triggers a special
mechanism in \fBjam\fR for scanning a file for header file inclusions
and invoking a rule with the results of the scan.  The $(HDRSCAN)
variable is set to an \fBegrep\fR(1) pattern that matches "#include"
statements in C source files, and the $(HDRRULE) variable is set to the
name of the rule that gets invoked as such:
.BB
$(HDRRULE) source-file : included-files ;
.BE
.PP
This rule is supposed to set up the dependencies between the source
file and the included files.  The \fIObject\fR rule uses
\fIHdrRule\fR to do the job.  \fIHdrRule\fR itself expects another
variable, $(HDRSEARCH), to be set to the list of directories where the
included files can be found.  \fIObject\fR does this as well, setting
$(HDRSEARCH) to $(HDRS) and $(STDHDRS).
.PP
The header file scanning occurs during the "file binding" phase of
\fBjam\fR, which means that the target-specific variables (for the
source file) are in effect.  To accomodate nested includes, one of the
\fIHdrRule\fR's jobs is to pass the values of $(HDRRULE), $(HDRSCAN),
and $(HDRSEARCH) onto the included files, so that they will be scanned
as well.
.SS HdrRule Rule
.PP
\fIHdrRule\fR can be invoked directly, but it is most usable as the
boilerplate in a user-defined $(HDRRULE).
.XB
Main mkhdr : mkhdr.c ;
Main ugly : ugly.c ;

HDRRULE on ugly.c = BuiltHeaders ;

rule BuiltHeaders
{
        DEPENDS $(>) : mkhdr ;
        HdrRule $(<) : $(>) ;
}
.XE
.PP
This example just says that the files included by "ugly.c" are generated
by the program "mkhdr", which can be built from "mkhdr.c".  By calling
\fIHdrRule\fR at the end of \fIBuiltHeaders\fR, all the gadgetry of 
\fIHdrRule\fR doesn't need to be duplicated.
.SS Variables
.PP
The complete list of variables used by the \fIHdrRule\fR coterie are:
.BB
HDRRULE         scan rule, when set activates scanning (HdrRule)
HDRSCAN         scan pattern ($(HDRPATTERN))
HDRSEARCH       search list for HdrRule ($(HDRS) $(STDHDRS))
HDRS            non-standard directories for headers ()
STDHDRS         standard directories for headers (/usr/include)
HDRPATTERN      scan pattern for $(HDRSCAN) (ugly egrep expression)
.BE
.SH COPYING FILES
.SS File Rule
The \fIFile\fR rule copies one file to another.
The target name needn't bear any relationship to the source name.
.XB
File $(DESTDIR)/foo : bar ;
.XE
.SS Buld Rule
The \fIBulk\fR rule is a shorthand for many invocations of the \fIFile\fR
rule when all files are going to the same directory.
.XB
Bulk /usr/local/lib/grob : grobvals.txt grobvars.txt ;
.XE
.SS Shell Rule
The \fIShell\fR rule is like the \fIFile\fR rule, except that it makes
sure the first line of the target is "#!/bin/sh" and sets the permission
to make the file executable.
.XB
Shell /usr/local/bin/add : add.sh ;
.XE
.SS Variables
The following variables are used when copying files:
.BB
FILEMODE        permissions for target file (644)
SHELLHEADER     first line of shell scripts (#!/bin/sh)
SHELLMODE       permissions for shell scripts (755)
.BE
.PP
These can be set target-specific.
.XB
Shell /usr/local/bin/add : add.awk ;
SHELLHEADER on /usr/local/bin/add = "#!/bin/awk -f" ;
.XE
.SH INSTALLING FILES
.SS InstallBin Rule
.PP
\fIInstallBin\fR calls \fBinstall\fR(1) to install executables in 
the target directory.  $(BINDIR) is set to /usr/local/bin for convenience.
.XB
Main add : add.c ;
Main sub : sub.c ;
InstallBin $(BINDIR) : add sub ;
.XE
.SS InstallLib Rule
\fIInstallLib\fR calls \fBinstall\fR(1) to install files in the target
directory.  $(LIBDIR) is set to /usr/local/lib for convenience.
.XB
InstallLib $(LIBDIR) : bighelp.txt ;
.XE
.SS InstallMan Rule
.PP
\fIInstallMan\fR calls \fBinstall\fR(1) to install manual pages in 
the appropriate subdirectories of the target directory.  $(MANDIR)
is set to /usr/local/man for convenience.
.XB
InstallMan /usr/local/man : add.1 sub.1 bigfile.8 ;
.XE
.SS InstallShell Rule
.PP
\fIInstallShell\fR calls \fBinstall\fR(1) to install shell scripts in 
the target directory.
.XB
Shell bugs : bugs.sh ;
InstallShell /usr/local/bin : bugs ;
.XE
.PP
The difference between \fIShell\fR and \fIInstallShell\fR is not much: they
both copy the source to the target.  The former also makes
sure the script begins with the magic string (#!/bin/sh); the latter uses
\fIinstall\fR(1) for the copy.
.SS Variables
.PP
The following variables control the installation rules:
.BB
BINDIR          InstallBin directory (/usr/local/bin)
LIBDIR          InstallLib directory (/usr/local/lib)
MANDIR          InstallMan directory (/usr/local/man)
INSTALL         The install program; uses cp if not set (install)
FILEMODE        generic permissions for InstallLib, InstallMan (644)
EXEMODE         generic permissions for InstallBin (711)
SHELLMODE       generic permissions for InstallShell (755)
.BE
.PP
The directory variables are just defined for convenience: they must
be passed as the target the appropriate \fIInstall\fR rule.
The \fIINSTALL\fR and mode variables must be set (globally) before 
calling the \fIInstall\fR rules to take effect.
.SH HANDLING DIRECTORY TREES
.PP
\fBJam\fR can build large projects spread across many directories in
one pass, tracking the relationships among all files.  It doesn't
require the user to change the invocations of normal rules like
\fIMain\fR, \fILibrary\fR, etc. to use non-local pathnames:  these
rules continue to refer to files in the directory of the
\fBJamfile\fR.  This section describes the \fBJambase\fR rules and
variables that supports this.
.PP
To build a whole directory tree at a time, the user must do three
things:
.IP 1.
Set an environment variable pointing to the root directory of the
source tree.  The root variable's name is left up to the user, but in these
examples we use TOP.
.IP 2.
Place at the root of the tree a file named \fBJamrules\fR.  (This file
can alternately be named by the variable $(xxxRULES), where xxx is
the name of the root variable).  This file could be empty, but
in practice it contains user-provided rules and variable definitions
that are shared throughout the tree, such as library names, header
directories, install directories, compiler flags, etc.  This file is
good candidate for automatic customizing with \fBautoconf\fR.
.IP 3.
Preface the \fBJamfile\fR in each directory with an invocation of
the \fISubDir\fR rule.
.SS SubDir Rule
.PP
The \fISubDir\fR rule does two things:
.IP 1.
It reads in the \fBJamrules\fR at the root of the tree, if that file
hasn't already been read in by a previous invocation of \fISubDir\fR.
.IP 2.
It sets a few variables that tell \fBjam\fR the name of the
\fBJamfile\fR's directory, so that \fBjam\fR may find source files that
are named local to the \fBJamfile\fR's directory.
.PP
The \fISubDir\fR rule takes as its first argument the root variable's
name and as subsequent arguments the directory names leading from the
root to the directory of the current \fBJamfile\fR.  Note that the name
of the subdirectory is given as individual elements:  the \fISubDir\fR
rule does not use system-specific directory name syntax.  
.PP
The \fISubDir\fR rule must be invoked before any rules that refer to
the contents of the directory - it is best to put it at the top of each
\fBJamfile\fR.
.XB
# Mondo src/util directory.

SubDir TOP src util ;

Main $(TOP)/bin/testutil : test.c ;

LinkLibraries $(TOP)/bin/testutil : $(TOP)/lib/libutil.a ;

Library $(TOP)/lib/libutil.a : gadgets.c gizmos.c widgets.c ;
.XE
.PP
This compiles four files in "$(TOP)/src/util", archives three of the
objects into "libutil.a", and links the whole thing into "testutil".
.SS SubInclude Rule
.PP
The \fISubInclude\fR rule sources the \fBJamfile\fR from the named
subdirectory.  Its arguments are the same format as \fISubDir\fR's, and
its only reason for being is to allow including a subdirectory
\fBJamfile\fR without having to use system-specific directory name
syntax.
.PP
The recommended practice is only to include one level of subdirectories
at a time, and let the \fBJamfile\fR in each subdirectory include its
subdirectories.  This allows a user to sit in any arbitrary directory
of the source tree and build that subtree.
.XB
# Top level Jamfile for mondo project.  
# 
# $(TOP) points to root of mondo tree (set in environment).

SubInclude TOP src ;    
SubInclude TOP man ;
SubInclude TOP misc ;
SubInclude TOP util ;
.XE
.PP
If a directory has both subdirectories of its own and files that
need building, the \fISubIncludes\fR should either before the \fISubDir\fR
rule or at the end of the \fBJamfile\fR - \fInot\fR between the 
\fISubDir\fR and other rule invocations.
.XB
# Mondo src code.

SubDir TOP src ;

Main mondo : mondo.c ;
LinkLibraries mondo : $(TOP)/lib/libmisc.a $(TOP)/lib/libutil.a ;

SubInclude TOP src misc ;
SubInclude TOP src util ;
.XE
.SS SubDirCcFlags, SubDirC++Flags, SubDirHdrs Rules
.PP
These rules set the values of $(SUBDIRCCFLAGS), $(SUBDIRC++FLAGS) and
$(SUBDIRHDRS), which are used by the \fICc\fR, \fIC++\fR, and
\fIObject\fR rules when setting the target-specific values for
$(CCFLAGS), $(C++FLAGS) and $(HDRS).  The \fISubDir\fR rule clears
these variables out, and thus they provide directory-specific values of
$(CCFLAGS), $(C++FLAGS)  and $(HDRS).
.XB
SubDir TOP src util ;

SubDirHdrs $(TOP)/src/hdr ;
SubDirCcFlags -DUSE_FAST_CODE ;
.SS Variables
The following variables are used when \fIJam\fR spans multiple directories:
.BB
LOCATE_TARGET   Directory to put targets.
SEARCH_SOURCE   Directory to find sources.
SOURCE_GRIST    Something to perturb source file names.
SUBDIRCCFLAGS   Per-directory CCFLAGS.
SUBDIRC++FLAGS  Per-directory C++FLAGS.
SUBDIRHDRS      Per-directory HDRS.
.BE
.PP
\fISubDir\fR sets $(LOCATE_TARGET) and $(SEARCH_SOURCE) to be the
directory given to \fISubDir\fR.  These variables are used extensively
by rules in \fBJambase\fR: most rules that generate targets (like
\fIMain\fR, \fIObject\fR, etc.) set $(LOCATE) to be $(LOCATE_TARGET)
for the targets they generate, and rules that use sources (most all of
them) set $(SEARCH) to be $(SEARCH_SOURCE) for the sources they use.
.PP
$(LOCATE) and $(SEARCH) are better explained in \fBjam\fR(1), but in
brief they tell \fBjam\fR where to create new targets and where to find
existing ones, respectively.
.PP
\fISubDir\fR sets $(SOURCE_GRIST) to be a value derived from the
directory name.  $(SOURCE_GRIST) is used by the rules that take
source files to perturb file names in different directories that
would otherwise be the same.
.PP
It should be noted that the user can set these variables independently
of \fISubDir\fR, or after it.  The most profitable example is setting
$(LOCATE_TARGET) to be a directory outside the source tree: in this
case, \fBjam\fR can build without even modifying the source tree.
.SH MISCELLANEOUS
.SS LibraryFromObjects Rule
.PP
Sometimes the \fILibrary\fR rule's straightforward compiling of source
into object modules to be archived isn't flexible enough.  The 
\fILibraryFromObjects\fR rule does the archiving (and deleting) job
of the \fILibrary\fR rule, but not the compiling.  The user can make
use of the \fIObjects\fR or \fIObject\fR rule for that.
.XB
LibraryFromObjects libfoo.a : max.o min.o ;
Object max.o : maxmin.c ;
Object min.o : maxmin.c ;
ObjectCcFlags max.c : -DUSEMAX ;
ObjectCcFlags min.c : -DUSEMIN ;
.XE
.PP
This compiles the same source file into two different objects, with
different compile flags, and archives them.  Note that
\fIObjectCcFlags\fR referred to the (nonexistent) source file names for
the objects.
.SS MainFromObjects Rule
.PP
Similar to \fILibraryFromObjects\fR, \fIMainFromObjects\fR does the linking
part of the \fIMain\fR rule, but not the compiling.
.XB
MainFromObjects w : w.o ;
MainFromObjects uptime : uptime.o ;
Object w.o : uptime.c ;
Object uptime.o : uptime.c ;
ObjectCcFlags w.c : -DW_CODE ;
.XE
.SS Clean Rule
.PP
The \fIClean\fR rule has only a simple action: to delete all of its
sources.  It is normally invoked with intermediate files as sources, so
that they can be cleaned out.  If \fIClean\fR is invoked with a target
and some sources, instructing \fBjam\fR to make the target will cause
it to delete the sources.
.XB
Clean zap : junk1 junk2 junk3 ;
.XE
.PP
Saying \f(CWjam zap\fP would cause it to delete junk1, junk2, and junk3.
.PP
All rules listed in this manual page, except the \fIInstall\fR ones, invoke
the following \fIClean\fR rule:
.BB
Clean clean : $(<) ;
.BE
The \fIInstall\fR rules invoke the following:
.BB
Clean uninstall : $(<) ;
.BE
.PP
Thus a \f(CWjam uninstall\fP removes anything created with the \fIInstall\fR
rules, and a \f(CWjam clean\fP removes anything created by the other rules
listed in this manual page.  It should be noted that \fBjam\fR's cleaning
mechanism gets rid of exactly the files it created, not miscellaneous junk
left around by the user.
.PP
Given other, user-defined targets, the \fIClean\fR rule selectively
remove other generated files.
.XB
rule M4 
{
        # File depends on it's m4 source

        DEPENDS $(<) : $(>) ;

        Clean m4clean : $(<) ;
}

actions M4
{
        m4 < $(>) > $(<)
}
.XE
.PP
Here a \f(CWjam m4clean\fR would remove all files created by \fBm4\fR.
.SS RmTemps Rule
.PP
Some intermediate files are meant to be temporary.  The \fIRmTemps\fR
rule makes such files with the TEMPORARY attribute, and then deletes
them after they are used.  To delete them only when they are finished
being used, \fIRmTemps\fR must be the last rule (with actions) invoked on
the target that uses the temporary files, and the sources to
\fIRmTempts\fR must be the temporary files themselves.
.XB
SpecialUserRuleA foo : bar ;
SpecialUserRuleB ola : foo ;
RmTemps ola : foo ;
.XE
.PP
This says: build "foo" using \fISpecialUserRuleA\fR and "ola"
using \fISpecialUserRuleB\fR.  Once that is done, remove "foo".
.SH SPECIAL TARGETS
.PP
\fBJam\fR has only one special target: \fIall\fR, which it tries
to build if no targets are on the command line.  \fBJambase\fR makes
several special targets which are dependencies of \fIall\fR:
.BB
all             - parent of first, shell, files, lib, exe
first           - first dependent of 'all', for potential initialization
shell           - parent of all Shell targets 
files           - parent of all File targets
lib             - parent of all Library targets
exe             - parent of all Main target
clean           - removes all Shell, File, Library, and Main targets
uninstall       - removes all Install targets
.BE
.PP
\fBJambase\fR marks all of these targets with \fBjam\fR's \fINOTFILE\fR 
attribute, meaning that they aren't to be found in the filesystem.
You can build selected components by using the \fIshell\fR, \fIfiles\fR,
\fIlib\fR, or \fIexe\fR targets on the command line.  You can remove
the files that \fBjam\fR built using the \fIclean\fR and \fIuninstall\fR
targets on the command line.  And you can arrange for \fBjam\fR to run
initialization commands by putting actions on the target \fIfirst\fR.
.XB
actions Initialize
{
	ECHO "This is a test of the jam initialization system."
}

Initialize first ;
.XE
.SH JAM BUILT-IN RULES AND VARIABLES
.PP
This section describes \fBjam\fR's built-in rules and variables.   Built-in
rules are uppercase, as opposed to the mixed-case rules defined by 
\fBJambase\fR.  These built-in rules, along with the other \fBjam\fR syntax 
for setting variables, provide the foundation upon which the \fBJambase\fR
is built.  A \fBJamfile\fR, or (more likely) a \fBJamrules\fR (q.v.),
can make use of these built-in rules and variables as well.
.SS DEPENDS, INCLUDES Rules
.PP
These two rules build the dependency graph, in slightly different ways.
\fIDEPENDS\fR simply makes its sources dependents of its targets.
\fIINCLUDES\fR makes its sources dependents of anything of which
its targets are dependents.  This reflects the dependencies that arise
when one source file includes another: the object built from the source
file depends both on the original and included source file, but the
two sources files don't depend on each other.
.XB
DEPENDS foo.o : foo.c ;
INCLUDES foo.c : foo.h ;
.XE
.PP
This examples makes "foo.o" depend on "foo.c" and "foo.h".
.SS ALWAYS, LAURA, NOCARE, NOTFILE, TEMPORARY Rules
.PP
These five rules modify targets so that \fBjam\fR treats them different
during its target binding and updating phase.  Normally, \fBjam\fR
updates a target if it can't be found, if it is older than its dependents,
or if its dependents are being updated.  Note that this only applies
to targets that are dependents of the targets given to \fBjam\fR on
the command line, or of the target \fIall\fR if there are no targets 
on the command line.
.PP
The \fIALWAYS\fR rule causes its targets to be always updated.  This is
used for the \fIclean\fR and \fIuninstall\fR targets, as they have no
dependents and would otherwise appear never to need building.
.PP
The \fINOCARE\fR rule suppresses \fBjam\fR's warning if its targets
can't be found and have no updating actions, and thus can't be built.
The \fIHdrRule\fR uses this to let \fBjam\fR know that header file names
found while scanning source files may not exist.
.PP
The \fINOTFILE\fR rule marks its targets as being pseudo targets, that
is, targets that aren't in the filesystem.  The \fIall\fR target is an
example of such a target.  These targets are built only if their
dependents are updated.
.PP
The \fITEMPORARY\fR rule allows for targets to be deleted after they
are generated.  If \fBjam\fR sees that a temporary target is missing,
it will use the target's parent's time when determining if the target
needs updating.  Object files that are also archived in a library are
marked as such, and they are deleted after they are archived.
.PP
The \fILAURA\fR rule makes each of its targets depend only on its "leaf" 
sources.  This makes it immune to its dependents being updated, as the
"leaf" soures are those without dependents or updating actions.
This allows a target to be updated only if original source files change.
.SS ECHO, EXIT Rules
.PP
These two rules help during the \fBJamfile\fR compiling phase.
The \fIECHO\fR rule just echoes its targets to the standard output.
The \fIEXIT\fR rule does the same and then does a brutal, fatal exit of
\fBjam\fR.
.SH JAMBASE REFERNCE
.SS Rules
.PP
\fBjam\fR normally tries to build the dependents of the target
\fIall\fR.  \fBJambase\fR defines the following dependents of
\fIall\fR:  \fIexe\fR, \fIfiles\fR, \fIinstall\fR, \fIlib\fR, and
\fIshell\fR.  Many of the rules defined below make their targets
dependents of one of these.
.de RP
.IP "\\$1"
.IP
..
.RP "As obj.o : source.s ;"
Assemble the file \fIsource.s\fR.  Called by the \fIObject\fR rule.
.RP "Bulk directory : sources ;"
Copies \fIsources\fR into \fIdirectory\fR. Dependents of \fIfiles\fR.
.RP "Cc object : source ;"
Compile the file \fIsource\fR into \fIobject\fR, using the C compiler
$(CC), its flags $(CCFLAGS) and $(OPTIM), and the header file
directories $(HDRS).  Called by the \fIObject\fR rule.
.RP "C++ obj.o : source.cc ;"
Compile the C++ source file \fIsource.cc\fR.  Called by the
\fIObject\fR rule.
.RP "Clean clean : targets ;"
Removes existing \fItargets\fR when \fIclean\fR is built.  \fIclean\fR
is not a dependency of \fIall\fR, and must be built explicitly for
\fItargets\fR to be removed.
.RP "File target : source ;"
Copies \fIsource\fR into \fItarget\fR.  Dependent of \fIfiles\fR.
.RP "Fortran obj.o : source.f ;"
Compile the Fortran source file \fIsource.f\fR.  Called by the
\fIObject\fR rule.
.RP "HardLink target : source ;"
Makes \fItarget\fR a hard link to \fIsource\fR, if it isn't one
already.
.RP "HdrRule source : headers ;"
Arranges the proper dependencies when the file \fIsource\fR includes
the files \fIheaders\fR through the "#include" C preprocessor
directive.  The \fIObject\fR rule arranges for this rule to be called
when \fBjam\fR does its header file scan of \fIsource\fR.
.RP "Install target : source ;"
Copies \fIsource\fR into \fItarget\fR, using \fIinstall\fR(1).  Used by
the other \fIInstall\fR* rules.
.RP "InstallBin dir : sources ; "
Copy \fIsources\fR into \fIdir\fR with mode $(EXEMODE).  Dependents of
\fIinstall\fR.
.RP "InstallLib dir : sources ;"
Copy \fIsources\fR into \fIdir\fR with mode $(FILEMODE).  Dependents of
\fIinstall\fR.
.RP "InstallMan dir : sources ;"
Copy \fIsources\fR into the appropriate subdirectory of \fIdir\fR with
mode $(FILEMODE).  The subdirectory is \fBman\fIs\fR, where \fIs\fR
is the suffix of each of \fIsources\fR.  Dependents of \fIinstall\fR.
.RP "InstallShell dir : sources ;"
Copy \fIsources\fR into \fIdir\fR with mode $(SHELLMODE).  Dependents
of \fIinstall\fR.
.RP "Lex source.c : source.l ;"
Process the \fBlex\fR(1) source file \fIsource.l\fR and rename the
lex.yy.c to \fIsource.c\fR.  Called by the \fIObject\fR rule.
.RP "Library library : sources ;"
Compiles \fIsources\fR and archives them into \fIlibrary\fR.  The
intermediate objects are deleted.  Calls \fIObjects\fR and
\fILibraryFromObjects\fR.  Dependent of \fIlib\fR.
.RP "LibraryFromObjects library : objects ;"
Archives \fIobjects\fR into \fIlibrary\fR.  The \fIobjects\fR are then
deleted.  Dependent of \fIlib\fR.
.RP "LinkLibraries image : libraries ;"
Makes \fIimage\fR depend on \fIlibraries\fR and includes them during
the linking.
.RP "Main image : sources ;"
Compiles \fIsources\fR and links them into \fIimage\fR.  Calls
\fIObjects\fR and \fIMainFromObjects\fR.  Dependent of \fIexe\fR.
.RP "MainFromObjects image : objects ;"
Links \fIobjects\fR into \fIimage\fR.  Dependent of \fIexe\fR.
.RP "Object object : source ;"
Compiles a single source file \fIsource\fR into \fIobject\fR.  Makes
\fIobject\fR depend on all header files included by \fIsource\fR.  Such
dependencies are "soft": missing headers are not an error.
.IP
Calls one of the rules listed to do the actual compiling, depending
on the suffix of \fIsource\fR:
.RS
.IP
source.c: \fICc\fR
.br
source.cc: \fIC++\fR
.br
source.cpp: \fIC++\fR
.br
source.C: \fIC++\fR
.br
source.l: \fILex\fR
.br
source.y: \fIYacc\fR
.br
source.*: \fIUserObject\fR
.RE
.IP
This rule is used by \fBObjects\fR.
.RP "ObjectCcFlags source : flags ;"
Add \fIflags\fR to the \fIsource\fR-specific value of $(CCFLAGS) when
compiling \fIsource\fR.  Any file suffix on \fIsource\fR is ignored.
.RP "ObjectHdrs source : dirs ;"
Add \fIdirs\fR to the \fIsource\fR-specific value of $(HDRS) when
scanning and compiling \fIsource\fR.  Any file suffix on \fIsource\fR
is ignored.
.RP "Objects sources ;"
For each source file in \fIsources\fR,
calls \fIObject\fR to compile the source file into a similarly named 
object file.
.RP "RmTemps targets : sources ;"
Marks \fIsources\fR as temporary with the \fBTEMPORARY\fR rule, and
deletes \fIsources\fR once \fItargets\fR are built.  Must be the last
rule invoked on \fItargets\fR.  Used internally by \fBObject\fR.
.RP "Setuid image ;"
Sets the setuid bit on \fIimage\fR after linking.
.RP "Shell image : source ;"
Copies \fIsource\fR into the executable \fBsh\fR(1) script \fIimage\fR.
Ensures that the first line of the script is $(SHELLHEADER) (default
\fI#!/bin/sh\fR).  Dependent of \fIshell\fR.
.RP "Undefines image : symbols ;"
Tries to convince the loader that symbols need to be "undefined" for
the linking of \fIimage\fR.
.RP "UserObject object : source ;"
Complains that the suffix on \fIsource\fR is unknown.  This rule is called
by \fIObject\fR for source files with unknown suffixes, and should be replaced
with a user-provided rule to handle the source file types.
.RP "Yacc source.c : source.y ;"
Process the \fByacc\fR(1) file \fIsource.y\fR and renamed the resulting
y.tab.c and y.tab.h to \fIsource.c\fR.  Produces a y.tab.h and renames it
to \fIsource\fR.h.  Called by the \fIObject\fR rule.
.SS Variables
.PP
AR (default \fI"ar ru"\fR)
.IP
The archiver used for \fBLibrary\fR.
.PP
AS (default \fIas\fR)
.IP
The assembler for \fBAs\fR.
.PP
ASFLAGS (no default)
.IP
Flags handed to the assembler for \fBAs\fR.
.PP
BINDIR (default \fI/usr/local/bin\fR)
.IP
Not used.  Set for convenience.
.PP
CC (default \fIcc\fR)
.IP
C compiler used for \fBObject\fR.
.PP
CCFLAGS (no default)
.IP
Flags handed to the C compiler for \fBObject\fR.  \fBOPTIM\fR is also
handed to the C compiler.
.PP
C++ (default \fIgcc\fR)
.IP
C++ compiler used for \fBC++\fR.
.PP
C++FLAGS (no default)
.IP
Flags handed to the C++ compiler for \fBC++\fR.  \fBOPTIM\fR is also
handed to the C++ compiler.
.PP
EXEMODE (default \fI711\fR)
.IP
Permissions for executables linked with \fBMain\fR.
.PP
FILEMODE (default \fI644\fR)
.IP
Permissions for files copied by \fBFile\fR or \fBBulk\fR.
.PP
FORTRAN (default \fIf77\fR)
.IP
The Fortran compiler used by \fBFortran\fR.
.PP
FORTRANFLAGS (no default)
.IP
Flags handed to the Fortran compiler for \fBFortran\fR.
.PP
HDRPATTERN (default ^#[\\t ]*include[\\t ]*[<"](.*)[">].*$)
.IP
The \fBregexp\fR(3) pattern for finding header file includes in source
files.  The \fBObject\fR rule sets the \fBjam\fR-special variable
\fBHDRSCAN\fR to $(\fBHDRPATTERN\fR) for all of its sources.  The
corresponding target of the \fBObject\fR rule invocation depends on all
header files found.
.PP
HDRS (no default)
.IP
Directories to be scanned for header files and handed to the C compiler
with -I.  The \fBObject\fR rule sets \fBHDRS\fR to $(HDRS) for each of
its sources.
.PP
JAMFILE (default \fIJamfile\fR)
.IP
The user-provided file listing the sources to be built.
.PP
LEX (default \fIlex\fR )
.IP
The \fBlex\fR(1) command and flags.
.PP
LIBDIR (default \fI/usr/local/lib\fR)
.IP
Not used.  Set for convenience.
.PP
LINK (default \fIcc\fR)
.IP
The linker.
.PP
LINKFLAGS (default \fI$(CCFLAGS)\fR)
.IP
Flags handed to the linker.
.PP
LINKLIBS (no default)
.IP
Libraries to hand to the linker.  The target image does not depend on
these libraries.
.PP
LOCATE_TARGET (no default)
.IP
The directory for object modules and other intermediate files generated
by \fBObject\fR.  This works by setting the \fBjam\fR-special variable
\fBLOCATE\fR to the value of $(\fBLOCATE_TARGET\fR) for each of
\fBObject\fR's targets.
.PP
LN (default \fIln\fR)
.IP
The hard link command for \fIHardLink\fR.
.PP
MANDIR (default \fI/usr/local/man\fR)
.IP
Not used.  Set for convenience.
.PP
MV (default \fImv -f\fR)
.IP
The file rename command and options.
.PP
OPTIM (default \fI-O\fR)
.IP
More flags handed to the C compiler.
.PP
RANLIB (default \fIranlib\fR)
.IP
If set, the command string to be invoked on each library after
archiving.
.PP
RM (default \fIrm -f\fR)
.IP
The command and options to remove a file.
.PP
SEARCH_SOURCE (no default)
.IP
The directory to find sources listed with \fBMain\fR, \fBLibrary\fR,
\fBObject\fR, \fBBulk\fR, \fBFile\fR, \fBShell\fR, \fBInstallBin\fR,
\fBInstallLib\fR, and \fBInstallMan\fR rules.  This works by setting
the \fBjam\fR-special variable \fBSEARCH\fR to the value of
$(\fBSEARCH_SOURCE\fR) for each of the rules' sources.
.PP
SHELLHEADER (default \fI#!/bin/sh\fR)
.IP
A string inserted to the first line of every file created by the
\fBShell\fR rule.
.PP
SHELLMODE (default \fI755\fR)
.IP
Permissions for files installed by \fBShell\fR.
.PP
STDHDRS (default \fI/usr/include\fR)
.IP
Directories where headers can be found without resorting to using the
\fIflag\fR to the C compiler.
.PP
UNDEFFLAG (default \fI-u _\fR)
.IP
The flag prefixed to each symbol for the \fBUndefines\fR rule.
.PP
YACC (default \fIyacc -d\fR)
.IP
The \fByacc\fR(1) command and flags.

.SH BUGS
.PP
Because libraries are passed unbound to the \fBLink\fR rule as
$(\fBNEEDLIBS\fR), they cannot be located with $(\fBLOCATE\fR), because
$(\fBLOCATE\fR) only changes the bound file name.
.PP
There's no \fByacc\fR(1) on VMS, so the guts of the rules are commented
out.
.SH SEE ALSO
\fBjam\fR(1)
